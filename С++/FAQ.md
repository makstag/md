## 1. В чём разница между объявлением, определением, инициализацией и реализацией?
#объявление #определение #инициализация #реализация

```C++
typedef int MyType; // объявление синонима типа

extern int value; // объявление переменной
int value;        // объявление + определение посредством неявной инициализации
int value2 = 0;   // объявление + определение посредством явной инициализации
				  // значением 0

int func();             // объявление функции (прототип функции)
int func(){ return 0; } // определение функции посредством реализации

class SomeClass; // объявление класса
class SomeClass  // определение класса
{ static int field; };    // объявление  static члена класса
int SomeClass::field = 0; // определение static члена класса посредством
						  // инициализации значением 0
```

**Явная и неявная инициализация переменных**
Если при определении переменной не происходит явного присвоения ей какого-либо значения (т.е. не происходит _явной инициализации_), то компилятор может проинициализировать её сам в соответствии со следующими правилами:
1. переменные со статическим временем существования (глобальные, в пространствах имен и статические) инициализируются нулем;
2. автоматические переменные не инициализируются (имеют случайное значение той области, которая была выделена под переменную на стеке);
3. динамические переменные не инициализируются (имеют случайное значение той области памяти, которая была выделена под объект в куче).

Стоит заметить, что в большинстве реализаций в debug-версии под автоматические переменные область стека (stack) заполняется значениями `0xCCCCCCCC`, а область кучи (heap) заполняется `0xCDCDCDCD`, что может позволить при отладке выявлять использование неинициализированных переменных.

***
## 2. Назовите этапы компиляции
[habr процесс компиляции](https://habr.com/ru/articles/478124/)
##### 1 Препроцессинг
На данной стадии происходит происходит работа с препроцессорными директивами
```bash
$ g++ -E driver.cpp -o driver.ii
```
##### 2 Компиляция (Трансляция)
На данном шаге g++ выполняет свою главную задачу — компилирует, то есть преобразует полученный на прошлом шаге код без директив в _ассемблерный код_. Используя флаг **-S**, который сообщает компилятору остановиться после стадии компиляции, получим ассемблерный код в выходном файле **driver.s**:
```bash
$ g++ -S driver.ii -o driver.s
```
##### 3 Ассемблирование
Ассемблер преобразовывает ассемблерный код в машинный код, сохраняя его в _объектном файле_.

> [!INFO]
> **Объектный файл** — это созданный ассемблером промежуточный файл, хранящий кусок машинного кода. Этот кусок машинного кода, который еще не был связан вместе с другими кусками машинного кода в конечную выполняемую программу, называется _объектным кодом_.

Далее возможно сохранение данного объектного кода в _статические библиотеки_ для того, чтобы не компилировать данный код снова. Получим машинный код с помощью ассемблера (**as**) в выходной объектный файл **driver.o**:
```bash 
$ as driver.s -o driver.o
```
##### 4 Линковка (Компоновка)
Линковка выполняется простым вызовом _g++_ от объектного файла. На выходе даёт исполняемый файл. Нужна, если файлов несколько: мы запускаем препроцессор, трансляцию и ассемблирование независимо для каждого файла, а объединяются они только на этапе линковки. Независимые _.cpp_ файлы называют _единицами трансляции_. Разумеется, **только в одной единице должен быть `main`**. В этом `main`'е, кстати, можно не делать `return 0`, его туда вставит компилятор.
```bash
$ g++ driver.o -o driver
```

***

