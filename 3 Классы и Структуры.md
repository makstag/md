1. Классы
    - [Классы и структуры](#классы-и-структуры)
    - [Перегрузка функций](#перегрузка-функций)
    - [Конструкторы и деструкторы](#конструкторы-и-деструкторы)
    - [Делегирующие конструкторы](#делегирующие-конструкторы)
    - [Оператор присваивания и правило трех](#оператор-присваивания-и-правило-трех)
    - [default и delete](#default-и-delete)
    - [Перегрузка операторов](#перегрузка-операторов)


# Классы

## Классы и структуры
* Отличаются только тем, что у классов поля по-умолчанию private, а у структуры public
* После определения структуры нужно ставить точку с запятой
* Данный структуры называются полями

```C++
struct S {
  int x = 1;
  double y = 3.14;
  char c = 'a';
};
```

* Можно инициализаровать поля при создании переменной S s{2, 2.72, 'b'}; (aggregate initialization) Те, переменные, которые не пронициализированы таким образом будут проинициализированы по-умолчанию. Если инициализации по-умолчанию нет, там будет мусор т.к. переменная лежит на стеке.
* Начиная с C++20 можно напрямую указывать какие поля инициализировать - designated initializers.
S s {.y = 2.72, .c = 'b' };


* Обращаться к полям структуры через оператор " . "
* Если нужно обратиться к полям указателя на структуру - используется оператор " -> " 
* В структуре можно объявлять методы
* есть ключевое слово this - указатель на данный объект
* можно метод объявить внутри структуры, но определить вне
* внутри структур можно тоже объявлять структуры (inner classes)

Можно объявлять структуры внутри функций - local classes.

Инкапсуляция и модификаторы доступа:
private - недоступно извне
public - доступно извне
Их можно писать сколько угодно раз в любом порядке.
  Функциям не членам класса можно разрешать доступ к приватным полям (только ко всем сразу) используя ключевое слово friend. Отношение дружбы не симметрично и не транзитивно.
friend void g();
Разрешить доступ можно и классам, тогда всем методам класса будут доступны приватные поля.
friend class SS;
Ключевое слово friend не рекомендовано код-стайлом.

## Перегрузка функций

1) Можно делать перегрузку в зависимости от того константное значение передается или нет:

```C++
void f(T&);
void f(const T&);
```

2) Нельзя перегружать передачу по значению и передачу по костантной ссылке - будет umbiguous call:

```C++
void f(T);
void f(const T&);  // ERROR
```

3) Нельзя перегружать передачу по значению и передачу по ссылке - будет umbiguous call:

```C++
void f(T);
void f(T&);  // ERROR
```

## Конструкторы и деструкторы

Как только появляется хоть один конструктор, пропадает возможность создавать экземпляры класса по умолчанию UserClass uc; - CE.

Если все поля проинициализированы по умолчанию, можно создать свой конструктор по умолчанию Widget::Widget(){} и теперь объявлять экземпляр класса как Widget w;

Когда мы зашли в тело конструктора - все поля уже проинициализированы.

Списки инициализации - constructor initializer list C++98 (не путать с теми, которые появились в C++11 - brace-enclosed initializer list) позволяет инициализировать переменную значением до входа в тело конструктора. Это быстрее за счет того, что переменные сразу будут проинициализировыны нужными значениями, а не мусором с последующей перезаписью нужным значением в теле конструктора. Также это позволяет инициализировать переменные у которых нет инициализации по умолчанию, например константные переменные или ссылки. Иначе при попытке создать конструктор по умолчанию компилятор выдаст CE.

```C++
class Complex {
public:
  double re = 0.0;
  double im = 0.0;

  Complex(double re, double im): re(re), im(im)
}
```

Если перечислить переменные в другом порядке, то будет ворнинг. Поля всегда инициализируются в том порядке в котором объявлены, а не в том, каком они указаны в списке инициализации.

```C++
Complex(double re, double im): im(im), re(re)
```

inializer_list

При подобных вызовах initialize_list приоритетнее обычного конструктора:
vector<int> v{1, 10};

> Начиная с C++11 все предпичитали inializer_list при инициализации, а начиная с C++17 можно не уточнять от чего vactor. И теперь рекомендуется не использовать {}, а использовать () если только не хочешь явно использовать inializer_list


## Делегирующие конструкторы

Начиная с C++11 один конструктор может делегировать некоторые работы другому. Чтобы добавить делегированные конструкторы, используйте constructor (. . .) : constructor (. . .) синтаксис. Причем конструктор делегирования должен быть единственным членом списка инициализации.

```C++
class class_a {
public:
    class_a() {}
    // member initialization нет делегирования
    class_a(string str) : m_string{ str } {}

    // невозможно выполнить member initialization здесь
    // error C3511: конструктор делегирования должен быть единственным членом списка инициализации
    class_a(string str, double dbl) : class_a(str) , m_double{ dbl } {}

    // конструктор делегирует часть работы другому конструктору
    class_a(string str, double dbl) : class_a(str) { m_double = dbl; }
    double m_double{ 1.0 };
    string m_string;
};
```

## Оператор присваивания и правило трех

```C++
String s = ss; // оператор копирования
s = ss;        // оператор присваивания
```

Операторы присваивания, копирования генерируются компилятором автоматически.
Правило трех - как только в классе хоть из трех вещей нужно реализовать самостоятельно (оператор копирования, присваивания, деструктор), то нужно реализовать все три.

## default и delete
> c C++11

Компилятор может сам генерировать шесть функций.
• Конструктор по умолчанию;
Object();
• деструктор;
~Object();
• копирующий конструктор;
Object(const Object& oth);
• оператор копирующего присваивания;
Object& operator=(const Object& oth);
• перемещающий конструктор;
Object(Object&& oth);
• оператор перемещающего присваивания;
Object& operator=(Object&& oth);

Ключевое слово default указывает на то, что мы хотим использовать версию этой функции сгенерированную компилятором, указывать тело функции в таком случае не нужно. Ключевое слово delete наоборот запрещает компилятору автоматически генерировать функцию с такой сигнатурой.

```C++
class C {
  C(const C&) = default;
  C(C&&) = delete;
};
```

## Перегрузка операторов
1:23:30
