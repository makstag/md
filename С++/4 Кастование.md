#Кастование
## Кастование

#### Неявный каст

Когда мы конвертируем значение из более крупного типа данных в аналогичный, но более мелкий тип данных, или конвертация происходит между разными типами данных, то это называется числовой конверсией. Например:

```C++
double d = 4; // конвертируем 4 (тип int) в double
short s = 3; // конвертируем 3 (тип int) в short
```

В отличие от расширений, которые всегда безопасны, конверсии могут (но не всегда) привести к потере данных. При обработке выражений компилятор разбивает каждое выражение на отдельные подвыражения. Арифметические операторы требуют, чтобы их операнды были одного типа данных. Чтобы это гарантировать, компилятор использует следующие правила:
  - Если операндом является целое число меньше (по размеру/диапазону) типа int, то оно подвергается интегральному расширению в int или в unsigned int.
  - Если операнды разных типов данных, то компилятор вычисляет операнд с наивысшим приоритетом и неявно конвертирует тип другого операнда в такой же тип, как у первого.

Приоритет типов операндов:
  - long double (самый высокий);
  - double;
  - float;
  - unsigned long long;
  - long long;
  - unsigned long;
  - long;
  - unsigned int;
  - int (самый низкий).

Мы можем использовать оператор ***typeid*** (который находится в заголовочном файле typeinfo), чтобы узнать решающий тип в выражении. Список имен ***typeid*** можно посмотреть здесь - [тыц](#оператор-typeid)

```C++
double a(3.0);
short b(2);
std::cout << typeid(a + b).name() << " " << a + b << std::endl;  // выведет d 5
```

#### static_cast

#static_cast [cppreference](https://en.cppreference.com/w/cpp/language/static_cast)

1) Создает копию
2) Проверка производится на уровне компиляции, так что в случае ошибки сообщение будет получено в момент сборки приложения или библиотеки
3) static_cast преобразует выражения одного статического типа в объекты и значения другого статического типа
4) Поддерживается преобразование численных типов, указателей и ссылок по иерархии наследования как вверх, так и вниз
5) Можно закастить любое выражение к void*
6) Можно закастить void* к любому указателю
7) Нельзя кастить между указателями на в принципе несовместимые типы. Например, указатель на double нельзя привести к указателю на int. Для трюков с нарушением type safety пользуйтесь reinterpret_cast.
8) Нельзя кастить указатели на типы, а также сами типы с несовместимыми атрибутами const и/или volatile. Если вам необходимо нарушить const-корректность, пользуйтесь const_cast.
9) Нельзя кастить указатель на функцию-член к указателю на обычную функцию, или указатель на код к указателю на данные. Для подобных случаев пользуйтесь reinterpret_cast.

#### const_cast

#const_cast [stack overflow](https://ru.stackoverflow.com/questions/1183139/%D0%BE%D0%B1%D1%8A%D1%8F%D1%81%D0%BD%D0%B8%D1%82%D0%B5-%D0%BF%D0%BE-const-cast)

1) Присваивать объекту, который был определён как const — это в любом случае UB
2) const_cast ни коим образом не снимает константность с самого объекта, он только «возвращает» переданное ему значение с нужным типом (это выражение также может быть «присваиваемым» (l-value))
3) Может применяться только к указателям и ссылкам

На практике const_cast используется довольно редко. Обычно это относительно грязный хак, чтобы или передать константный объект в функцию, которая заведомо его не меняет (но принимает неконстантную ссылку/указатель)

```C++
void bar (int *i) {
  std::cout << *i;
}

// ...

const int ci=2;
bar(const_cast<int*>(&ci));
```

или, наоборот, изменить объект заведомо созданные как неконстантный, но переданный по константной ссылке/указателю. В тривиальном варианте это выглядит как-то так:


```C++
void foo (const int &i) {
  const_cast<int &>(i) = 2;
}

// ...

int i=0;
foo(i);
```

#### reinterpret_cast

Особенности #reinterpret_cast
1) Нужно кастовать только к указателям и ссылкам
2) Читает биты одного типа, как если бы это был другой
3) Не умеет снимать const

В данном случае 'x' и 'y' будут указывать на одно значение и изменение x будет меняться y и наоборот:
```C++
float &y = reinterpret_cast<float&>(x);
```
В данном случае будет создана отдельная переменная:
```C++
float y =  reinterpret_cast<float&>(x);
```

Существует несколько разных преобразований. cppreference.com выделяет 11 вариантов преобразований:

  - В свой собственный тип
  - Указателя в интегральный тип
  - Интегрального типа в указатель
  - Типа std::nullptr_t в интегральный тип
  - Указателя одного типа в указатель другого типа
  - lvalue одного типа в ссылку на другой тип
  - Указателя на функцию одного типа в указатель на функцию другого типа
  - Указателя на функцию в void*
  - Нулевого указателя любого типа в указатель любого другого типа
  - rvalue указатель одного типа на функцию-член в указатель другого типа на функцию-член
  - rvalue указатель члена-данных одного типа в указатель ну другой член-данных другого типа

Type aliasing-правила затрагивают только пункты 5 и 6 и результат может быть безопасно использован (т.е. без нарушения strict-aliasing) в следующих случаях:

  - Результирующий тип есть динамический тип исходного объекта
  - Результирующий тип и динамический тип указывают на одинаковый тип T
  - Результирующий тип есть знаковый или беззнаковый вариант типа исходного объекта
  - Результирующий тип есть агрегатный тип или union, в котором содержится элемент или нестатический член данных, используемый в качестве исходного объекта. Т.е. можно получить указатель на структуру по указателю на её член.
  - Результирующий тип есть базовый класс динамического типа исходного объекта и этот тип является standard-layout классом и не содержит нестатических членов-данных, и результирующий тип - первый базовый класс.
  - Результирующий тип есть указатель на char, unsigned char или std::byte.

#### dynamic _cast

Синтаксис #dynamic_cast:

```C++
TYPE& dynamic_cast<TYPE&> (object);
TYPE* dynamic_cast<TYPE*> (object);
```

Используется для динамического приведения типов во время выполнения. В случае неправильного приведения типов для ссылок вызывается исключительная ситуация std::bad_cast, а для указателей будет возвращен 0. Использует систему RTTI (Runtime Type Information). Безопасное приведение типов по иерархии наследования, в том числе для виртуального наследования. 

#### С-style cast
Лучше избегать использования c-style cast
1) Сначала он пробует нельзя ли обойтись одним const_cast
2) Если нельзя, он пытается сделать static_cast
3) Если нельзя, он пытается сделать static_cast, а поверх него const_cast
4) Если нельзя, он пытается сделать reinterpret_cast
5) Если нельзя, он пытается сделать reinterpret_cast, а поверх него const_cast
6) Если ничего из этого нельзя - CE