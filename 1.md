
// 10

Можно для своего типа написать кастомные правила, как вывести тип аргумента шаблонного класса при переданных параметрах, это незывается `Explicit template deducction guides`

```C++
template <typename T>
struct vector {
    template <typename Iter>
    vector(Iter, Iter) {}
};

// С++17 пример Explicit template deducction guides
// начиная с С++20 можно это не писать, он сам выведет
template <typename Iter>
vector(Iter, Iter)
    -> vector<typename std::iterator_traits<Iter>::value_type>;
```

----

// 1
```C++
template <typename T>
class unique_ptr{
    T* ptr;

public:
    unique_ptr(T* ptr): ptr(ptr) {}
    ~unique_ptr() {
        delete ptr;
    }
    unique_ptr(const unique_ptr&) = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;

    unique_ptr(unique_ptr&& other)
            : ptr(other.ptr) {
        othrt.ptr = nullptr;
    }
    unique_ptr& operator=(unique_ptr&& other) {
        if (this != &other) {
            delete ptr;
            ptr = other.ptr;
            other.ptr = nullptr;
        }
        return *this;
    }
}
```

// 2
```C++
T& opetaror() const {
    return *ptr;
}
T* operator->() const {
    return ptr;
}
```