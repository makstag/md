
1. Введение
    - [Ошибки](#ошибки)
    - [Виды памяти, первое приближение](#виды-памяти-первое-приближение)
2. Переменные
    - [Инициализация переменных](#инициализация-переменных)
2. Операторы
    - [Указатели](#указатели)
    - [Ссылки](#ссылки)
    - [Оператор new](#оператор-new)
    - [Оператор delete](#оператор-delete)
    - [Оператор typeid](#оператор-typeid)
3. Ключевые слова
    - [Ключевое слово static](#ключевое-слово-static)
    - [Ключевое слово const](#ключевое-слово-const)
4. Массивы
    - [Массив []](#массив)
    - [std vector](#std-vector)
5. Функции
    - [Виды передачи переменных в функции](#виды-передачи-переменных-в-функции)
6. Классы
    - [Классы и структуры](#классы-и-структуры)
    - [Перегрузка функций](#перегрузка-функций)
    - [Конструкторы и деструкторы](#конструкторы-и-деструкторы)
    - [Делегирующие конструкторы](#делегирующие-конструкторы)
    - [Оператор присваивания и правило трех](#оператор-присваивания-и-правило-трех)
    - [default и delete](#default-и-delete)
    - [Перегрузка операторов](#перегрузка-операторов)
7. Кастование
    - [Неявный каст](#неявный-каст)
    - [static_cast](#static_cast)
    - [const_cast](#const_cast)
    - [reinterpret_cast](#reinterpret_cast)
    - [dynamic_cast](#dynamic_cast)
    - [С-style cast](#с-style-cast)

# Введение
## Ошибки
1. ***UB (undefined behaviour)*** — когда не гарантируется ничего.
2. ***Unspecified behaviour*** — не гарантируется порядок выполнения, но количество вариантов того, что может произойти конечен. Например, в выражении ```f1(x) + f2(y) + f3(z);``` стандартом не гарантируется порядок вычисления операндов, но существует всего 6 возможных вариантов.
3. ***Run-time error*** — ошибка во время выполнения программы.
4. ***Compilation error*** — ошибка на этапе компиляции или линковки.

***Segmentation fault*** — программа пытается получить доступ к памяти, которая не выделена под нее системой, ядро системы принудительно завершает выполнение программы. Если, например, выйти недалеко за пределы массива, можно просто получить UB, данные по этому адресу будут случайные.

## Виды памяти, первое приближение
При запуске программы ей выделяется область оперативной памяти в которой хранится следующее:
1. ***data (static memory)*** — переменные, которые перманентно хранятся в памяти (глобальные переменные, константы, строки);
2. ***text*** — машинный код программы;
3. ***stack (automatic memory)*** — локальные переменные (нестатические). Также там хранятся адреса возврата, параметры функций. Стандартно стек это 8мб (можно посмотреть командой ulimit -s). При переполнинии стека программа упадет с ошибкой – stack overflow. При завершении функции или после выхода из области видимости указатель стека переносится и теперь обращение по указателям на эту память становится UB.
4. ***dynamic memory*** — память, которая запрашивается программой в run-time'е (оператор new, функции malloc, calloc, realloc). Динамические объекты существуют, пока не будут удалены явным образом.

# Переменные
## Инициализация переменных

Если переменные или поля класса не проинициализированы явно, то там будут храниться случайные значения.

с (aggregate initialization). Она выполняется, когда массив инициализируется рядом значений в фигурных скобках:

```C++
int i[4] = {0, 1, 2, 3};
```

Если при этом не указать размер массива, то он выводится из количества значений, заключённых в скобки:

```C++
int i[0] = {0, 1, 2, 3, 4};

struct Widget {
  int i;
  float j;
};

Widget widget = {1, 3.14159};
```

Этот синтаксис работал ещё в С и С++98, причём, начиная с С++11, в нём можно пропускать знак равенства:

```C++
Widget widget{1, 3.14159};
```

Если определен собственный конструктор и мы пишем {}, то все равно вызывается он, а не происходит агрегатная инициализация! Также может быть специальный конструктор от initializer_list и тогда будет вызываться он при вызове {}.

В C++11 были добавлены инициализаторы элементов по умолчанию (default member initialisers).

```C++
struct Widget {
  int i = 0;
  float j = 0.f;
};
```

# Операторы
## Указатели
**Void*** - указатель на произвольную память. Его нельзя разыменовать, но можно кастануть в какой-то тип указателя и присвоить в другой указатель, если по этой памяти действительно лежит переменная с таким типом, то все ок, иначе UB.

Все стандартные функции выделения памяти возвращают указатель кратный максимально возможной степени двойки по которой могут ложиться типы (как правило 16).

nullptr (типа std::nullptr_t) - аналог нуля для указателей. Раньше для этого использовался макрос NULL со значением 0 – целым типом. В целях обратной совместимости константа 0 также может использоваться в качестве нулевого указателя.

## Ссылки

В ссылке, как и в указателе, хранится адрес объекта, расположенного в другой области памяти. В отличие от указателя, после инициализации ссылку нельзя перенаправить на другой объект или присвоить ей нулевое значение. Основные особенности:
1) При объявлении ссылка должны быть проинициализированна lvalue
2) Можно делать ссылки на функции (void (&F)() = g())
3) Нельзя делать ссылку на void
4) Нельзя делать массив ссылок (int& a[10]), но можно ссылку на массив (int (&a)[10])
5) Нельзя делать указатель на ссылку, но можно ссылку на указатель

```C++
int* p = nullptr;
int*& r = p;
```

6) Нельзя делать константный указатель int & const - CE

7) dangling reference — висячие ссылка возникают тогда, когда объект удалён, на который указывает ссылка удален. Пример, в случаях ниже ссылка будет указывать на локальную переменную функции, но при выходе из функции она снимается со стека и дальнейшее использование ссылки на нее будет UB.

```C++
int& f() {
  int x = 0;
  return x;
}

int& f(int x) {
  return x;
}
```

8) sizeof() ссылки будет возвращать размер объекта, а не размер указателя

```C++
struct S{
    int i[20];
};

int main()
{
   S s;
   S *ptr = &s;
   S &ref = s;
   
   cout << "sizeof S : " << sizeof(S) << endl;   // sizeof S : 80
   cout << "sizeof * : " << sizeof(ptr) << endl; // sizeof * : 8
   cout << "sizeof & : " << sizeof(ref) << endl; // sizeof & : 80
   return 0;
}
```

9) Обращение к объекту по ссылке будет занимать больше времени, чем напрямую к объекту т.к. будет выполняться разименование.

10) По указателям можно освобождать память, но это нежелательно. Хранение памяти по указателю скрывает от пользователя необходимость обращаться с памятью и затрудняет правильное выполнение этой операции. (https://stackoverflow.com/questions/3233987/deleting-a-reference)

```C++
int& f() {
  int *p = new int;
  return *p;
}

int &p = f();
delete &p;
```

11) нельзя перегружать функции сследующим образом

```C++
void f(int);
void f(int&);
```

12) При создании ссылки на константную и несовпадении типов объектов может произойти неявный каст, который возвращает rvalue.

## Оператор new
```C++
int *p = new int;
int *pp = new int(5);
int *set = new int[100]; // объявление массива
```

## Оператор delete
```C++
delete p;
delete pp;
delete [] set; // освобождение памяти массива
```

## Оператор typeid

Оператор typeid позволяет определить тип объекта во время выполнения. Применение:
```C++
typeid(bool).name() // b
```
Примеры вывода для разных типов:
- bool = b
- char = c
- unsigned char = h
- short = s
- unsigned short = t
- int = i
- unsigned int = j
- long = l
- unsigned long = m
- long long = x
- unsigned long long = y
- float = f
- double = d
- long double = e
- string = Ss
- int[] = A_i
- double[] = A_d
- vector<int> = St6vectorIiSaIiEE
- set<int> = St3setIiSt4lessIiESaIiEE
- pair<int, int> = St4pairIiiE
- map<int, int> = St3mapIiiSt4lessIiESaISt4pairIKiiEEE
- stack<int> = St5stackIiSt5dequeIiSaIiEEE
- queue<int> = St5queueIiSt5dequeIiSaIiEEE
- deque<int> = St5dequeIiSaIiEE
- priority_queue<int> = St14priority_queueIiSt6vectorIiSaIiEESt4lessIiEE
- tuple<int, int, int, int> = St5tupleIIiiiiEE
- map< pair<int, int>, vector< priority_queue<int> > > = St3mapISt4pairIiiESt6vectorISt14priority_queueIiS2_IiSaIiEESt4lessIiEESaIS8_EES6_IS1_ESaIS0_IKS1_SA_EEE

# Ключевые слова
## Ключевое слово static
Локальные статические переменные хранятся в static memory. Статическая переменная определяется только один раз и будет существовать, даже если объекты класса не были созданы. Если static массив проинициализирован, bin file будет содержать его в себе. Для инициализации статической переменной в классе нужно добавить ключевое слово inline.
```C++
statuc inline unsigned count{}; // инициализируем нулем
```
Статические функции – в отличие от глобальных функций, статические функции доступны только из файла объявления. Используйте статическую функцию, чтобы ограничить повторное использование того же имени функции в другом файле.

Статические функция-член класса — когда член функции объявляется статическим, он становится независимым от других объектов класса. Можно вызвать статическую функцию-член, даже если других объектов класса не существует. Чтобы получить доступ к именам класса, нужно использовать имя класса и оператор разрешения области « :: ». Статическая функция может обращаться только к другим статическим функциях, статическим членам данных и другим функицям вне класса.

## Ключевое слово const

Для переменных с ключевым словом const запрещены некторые операции: = += ++ -- и т.д. Также компилятор может решить оптимизировать выполнение программы и, например, не заводить ячейку памяти для переменной, а напрямую поставить ее в выражение.

Можно делать константные ссылки на неконстантные переменные:

```C++
int a = 0;
const int &b = a;
```

это одна и та же переменная, но обращаясь через b ее нельзя менять, а обращаясь через а - можно. Теперь (int &c = b) это CE.

# Массивы
## Массив []
Размер массива N должен иметь неявное приведение к типу std::size_t, а его значение должно быть больше 0. Массив распологается в непрерывном отрезке памяти и занимает N*sizeof(T) байт.

Если массив объявлен статически, то есть в глобальной области видимости, в области видимости пространства имен или в качестве статического члена класса, то он размещается в статической памяти. Массивам объявленным локально, память выделяется на стеке.

Если массив объявлен в глобальной области видимости и не инициализирован, он будет иметь все биты 0, если локально или динамически, то получит случайный набор битов.

Массивы не поддерживают привычный синтаксис присваивания, основанный на семантике копирования. Но если массив является членом класса/структуры/обединения, то копирующий контструктор и соответствующий оператор присваивания, генерируемые компилятором, выполняют поэлементное копирование такого массива.

Нельзя объявлять массив ссылкок, функций. Также функция не может возврящать массив.
Не имеет значения порядок названия массива и индекса. Для компилятора следующие выражения эквивалентны и будут указывать на одну и ту же память:
```C++
p[1] <=> *(p+1)
1[p] <=> *(1+p)
```
Можно неявно сконвертировать массив T в указатель на T.
```C++
double a[10]; // массив из 10 элементов
double *p = a;
```
Принципиальные отличия массивов от указателей:
  - нельзя сделать инкремент и декремент;
  - sizeof от массива это сумма sizeof-ов от всех его элементов;
  - массивам нельзя присваивать другие массивы – будет compile-time error.

## std vector
Vector является динамическим массивом и его данные хранятся в динамической памяти, поэтому sizeof(vector) - 24 байта на x64. На стеке хранится только следующее:
    • _M_start - начало выделенной памяти;
    • _M_finish - последний вставленный элемент;
    • _M_end_of_storage - конец выделенной памяти.
Иногда (в stl из visual studio) на стеке также будет храниться аллокатор.

# Функции
## Виды передачи переменных в функции

Основные способы передачи переменных в функции в современном C++
1) передача по значению void f(T);
2) передача по ссылке void f(T&);
3) передача по константной ссылке void f(const T&);

Передача по значению полностью копирует объект T и работает уже с копией. Для больших объектов выгоднее передача по константной ссылке (или просто по ссылке, если объект нужно будет изменять), а для примитивных типов (int, float ..) передача по значению т.к. будет отсутствовать разыменование.

Передача по указателю как правило не используется, ссылки пришлина замену указателям.

В функции с сигнатурой типа f(const T&) можно передавать rvalue - это называется life-time prolongation. При этом f(T&) не умеет продлевать жизнь для rvalue.

# Классы

## Классы и структуры
* Отличаются только тем, что у классов поля по-умолчанию private, а у структуры public
* После определения структуры нужно ставить точку с запятой
* Данный структуры называются полями

```C++
struct S {
  int x = 1;
  double y = 3.14;
  char c = 'a';
};
```

* Можно инициализаровать поля при создании переменной S s{2, 2.72, 'b'}; (aggregate initialization) Те, переменные, которые не пронициализированы таким образом будут проинициализированы по-умолчанию. Если инициализации по-умолчанию нет, там будет мусор т.к. переменная лежит на стеке.
* Начиная с C++20 можно напрямую указывать какие поля инициализировать - designated initializers.
S s {.y = 2.72, .c = 'b' };


* Обращаться к полям структуры через оператор " . "
* Если нужно обратиться к полям указателя на структуру - используется оператор " -> " 
* В структуре можно объявлять методы
* есть ключевое слово this - указатель на данный объект
* можно метод объявить внутри структуры, но определить вне
* внутри структур можно тоже объявлять структуры (inner classes)

Можно объявлять структуры внутри функций - local classes.

Инкапсуляция и модификаторы доступа:
private - недоступно извне
public - доступно извне
Их можно писать сколько угодно раз в любом порядке.
  Функциям не членам класса можно разрешать доступ к приватным полям (только ко всем сразу) используя ключевое слово friend. Отношение дружбы не симметрично и не транзитивно.
friend void g();
Разрешить доступ можно и классам, тогда всем методам класса будут доступны приватные поля.
friend class SS;
Ключевое слово friend не рекомендовано код-стайлом.

## Перегрузка функций

1) Можно делать перегрузку в зависимости от того константное значение передается или нет:

```C++
void f(T&);
void f(const T&);
```

2) Нельзя перегружать передачу по значению и передачу по костантной ссылке - будет umbiguous call:

```C++
void f(T);
void f(const T&);  // ERROR
```

3) Нельзя перегружать передачу по значению и передачу по ссылке - будет umbiguous call:

```C++
void f(T);
void f(T&);  // ERROR
```

## Конструкторы и деструкторы

Как только появляется хоть один конструктор, пропадает возможность создавать экземпляры класса по умолчанию UserClass uc; - CE.

Если все поля проинициализированы по умолчанию, можно создать свой конструктор по умолчанию Widget::Widget(){} и теперь объявлять экземпляр класса как Widget w;

Когда мы зашли в тело конструктора - все поля уже проинициализированы.

Списки инициализации - constructor initializer list C++98 (не путать с теми, которые появились в C++11 - brace-enclosed initializer list) позволяет инициализировать переменную значением до входа в тело конструктора. Это быстрее за счет того, что переменные сразу будут проинициализировыны нужными значениями, а не мусором с последующей перезаписью нужным значением в теле конструктора. Также это позволяет инициализировать переменные у которых нет инициализации по умолчанию, например константные переменные или ссылки. Иначе при попытке создать конструктор по умолчанию компилятор выдаст CE.

```C++
class Complex {
public:
  double re = 0.0;
  double im = 0.0;

  Complex(double re, double im): re(re), im(im)
}
```

Если перечислить переменные в другом порядке, то будет ворнинг. Поля всегда инициализируются в том порядке в котором объявлены, а не в том, каком они указаны в списке инициализации.

```C++
Complex(double re, double im): im(im), re(re)
```

inializer_list

При подобных вызовах initialize_list приоритетнее обычного конструктора:
vector<int> v{1, 10};

> Начиная с C++11 все предпичитали inializer_list при инициализации, а начиная с C++17 можно не уточнять от чего vactor. И теперь рекомендуется не использовать {}, а использовать () если только не хочешь явно использовать inializer_list


## Делегирующие конструкторы

Начиная с C++11 один конструктор может делегировать некоторые работы другому. Чтобы добавить делегированные конструкторы, используйте constructor (. . .) : constructor (. . .) синтаксис. Причем конструктор делегирования должен быть единственным членом списка инициализации.

```C++
class class_a {
public:
    class_a() {}
    // member initialization нет делегирования
    class_a(string str) : m_string{ str } {}

    // невозможно выполнить member initialization здесь
    // error C3511: конструктор делегирования должен быть единственным членом списка инициализации
    class_a(string str, double dbl) : class_a(str) , m_double{ dbl } {}

    // конструктор делегирует часть работы другому конструктору
    class_a(string str, double dbl) : class_a(str) { m_double = dbl; }
    double m_double{ 1.0 };
    string m_string;
};
```

## Оператор присваивания и правило трех

```C++
String s = ss; // оператор копирования
s = ss;        // оператор присваивания
```

Операторы присваивания, копирования генерируются компилятором автоматически.
Правило трех - как только в классе хоть из трех вещей нужно реализовать самостоятельно (оператор копирования, присваивания, деструктор), то нужно реализовать все три.

## default и delete
> c C++11

Компилятор может сам генерировать шесть функций.
• Конструктор по умолчанию;
Object();
• деструктор;
~Object();
• копирующий конструктор;
Object(const Object& oth);
• оператор копирующего присваивания;
Object& operator=(const Object& oth);
• перемещающий конструктор;
Object(Object&& oth);
• оператор перемещающего присваивания;
Object& operator=(Object&& oth);

Ключевое слово default указывает на то, что мы хотим использовать версию этой функции сгенерированную компилятором, указывать тело функции в таком случае не нужно. Ключевое слово delete наоборот запрещает компилятору автоматически генерировать функцию с такой сигнатурой.

```C++
class C {
  C(const C&) = default;
  C(C&&) = delete;
};
```

## Перегрузка операторов
1:23:30

# Кастование

## Неявный каст

Когда мы конвертируем значение из более крупного типа данных в аналогичный, но более мелкий тип данных, или конвертация происходит между разными типами данных, то это называется числовой конверсией. Например:

```C++
double d = 4; // конвертируем 4 (тип int) в double
short s = 3; // конвертируем 3 (тип int) в short
```

В отличие от расширений, которые всегда безопасны, конверсии могут (но не всегда) привести к потере данных. При обработке выражений компилятор разбивает каждое выражение на отдельные подвыражения. Арифметические операторы требуют, чтобы их операнды были одного типа данных. Чтобы это гарантировать, компилятор использует следующие правила:
  - Если операндом является целое число меньше (по размеру/диапазону) типа int, то оно подвергается интегральному расширению в int или в unsigned int.
  - Если операнды разных типов данных, то компилятор вычисляет операнд с наивысшим приоритетом и неявно конвертирует тип другого операнда в такой же тип, как у первого.

Приоритет типов операндов:
  - long double (самый высокий);
  - double;
  - float;
  - unsigned long long;
  - long long;
  - unsigned long;
  - long;
  - unsigned int;
  - int (самый низкий).

Мы можем использовать оператор ***typeid*** (который находится в заголовочном файле typeinfo), чтобы узнать решающий тип в выражении. Список имен ***typeid*** можно посмотреть здесь - [тыц](#оператор-typeid)

```C++
double a(3.0);
short b(2);
std::cout << typeid(a + b).name() << " " << a + b << std::endl;  // выведет d 5
```

## static_cast

[cppreference](https://en.cppreference.com/w/cpp/language/static_cast)

1) Создает копию
2) Проверка производится на уровне компиляции, так что в случае ошибки сообщение будет получено в момент сборки приложения или библиотеки
3) static_cast преобразует выражения одного статического типа в объекты и значения другого статического типа
4) Поддерживается преобразование численных типов, указателей и ссылок по иерархии наследования как вверх, так и вниз

## const_cast

[stack overflow](https://ru.stackoverflow.com/questions/1183139/%D0%BE%D0%B1%D1%8A%D1%8F%D1%81%D0%BD%D0%B8%D1%82%D0%B5-%D0%BF%D0%BE-const-cast)

1) Присваивать объекту, который был определён как const — это в любом случае UB
2) const_cast ни коим образом не снимает константность с самого объекта, он только «возвращает» переданное ему значение с нужным типом (это выражение также может быть «присваиваемым» (l-value))
3) Может применяться только к указателям и ссылкам

На практике const_cast используется довольно редко. Обычно это относительно грязный хак, чтобы или передать константный объект в функцию, которая заведомо его не меняет (но принимает неконстантную ссылку/указатель)

```C++
void bar (int *i) {
  std::cout << *i;
}

// ...

const int ci=2;
bar(const_cast<int*>(&ci));
```

или, наоборот, изменить объект заведомо созданные как неконстантный, но переданный по константной ссылке/указателю. В тривиальном варианте это выглядит как-то так:


```C++
void foo (const int &i) {
  const_cast<int &>(i) = 2;
}

// ...

int i=0;
foo(i);
```

## reinterpret_cast

1) Нужно кастовать только к указателям и ссылкам
2) Читает биты одного типа, как если бы это был другой
3) Не умеет снимать const

В данном случае 'x' и 'y' будут указывать на одно значение и изменение x будет меняться y и наоборот:
```C++
float &y = reinterpret_cast<float&>(x);
```
В данном случае будет создана отдельная переменная:
```C++
float y =  reinterpret_cast<float&>(x);
```

Существует несколько разных преобразований. cppreference.com выделяет 11 вариантов преобразований:

  - В свой собственный тип
  - Указателя в интегральный тип
  - Интегрального типа в указатель
  - Типа std::nullptr_t в интегральный тип
  - Указателя одного типа в указатель другого типа
  - lvalue одного типа в ссылку на другой тип
  - Указателя на функцию одного типа в указатель на функцию другого типа
  - Указателя на функцию в void*
  - Нулевого указателя любого типа в указатель любого другого типа
  - rvalue указатель одного типа на функцию-член в указатель другого типа на функцию-член
  - rvalue указатель члена-данных одного типа в указатель ну другой член-данных другого типа

Type aliasing-правила затрагивают только пункты 5 и 6 и результат может быть безопасно использован (т.е. без нарушения strict-aliasing) в следующих случаях:

  - Результирующий тип есть динамический тип исходного объекта
  - Результирующий тип и динамический тип указывают на одинаковый тип T
  - Результирующий тип есть знаковый или беззнаковый вариант типа исходного объекта
  - Результирующий тип есть агрегатный тип или union, в котором содержится элемент или нестатический член данных, используемый в качестве исходного объекта. Т.е. можно получить указатель на структуру по указателю на её член.
  - Результирующий тип есть базовый класс динамического типа исходного объекта и этот тип является standard-layout классом и не содержит нестатических членов-данных, и результирующий тип - первый базовый класс.
  - Результирующий тип есть указатель на char, unsigned char или std::byte.

## dynamic _ast

Синтаксис:

```C++
TYPE& dynamic_cast<TYPE&> (object);
TYPE* dynamic_cast<TYPE*> (object);
```

Используется для динамического приведения типов во время выполнения. В случае неправильного приведения типов для ссылок вызывается исключительная ситуация std::bad_cast, а для указателей будет возвращен 0. Использует систему RTTI (Runtime Type Information). Безопасное приведение типов по иерархии наследования, в том числе для виртуального наследования. 

## С-style cast
Лучше избегать использования c-style cast
1) Сначала он пробует нельзя ли обойтись одним const_cast
2) Если нельзя, он пытается сделать static_cast
3) Если нельзя, он пытается сделать static_cast, а поверх него const_cast
4) Если нельзя, он пытается сделать reinterpret_cast
5) Если нельзя, он пытается сделать reinterpret_cast, а поверх него const_cast
6) Если ничего из этого нельзя - CE