[cppreference containers](https://en.cppreference.com/w/cpp/container)

Методы стандартных контейнеров можно посмотреть здесь: `pics/methods.canvas`

Об итераторах: [[0 Итераторы и их категории]]

***
## Инвалидация итераторов и ссылок

Если контейнер изменяется, то в некоторых случаях итераторы и ссылки (указатели) на элементы могут стать невалидными. (`pics/iterator invalidation.png`)
![[iterator invalidation.png]]
1. Строка `std::string` ведёт себя так же, как и вектор: все итераторы и ссылки инвалидируются.
2. В `std::array` ничего вставить нельзя, его размер фиксирован.
3. В `std::deque` инвалидируются итераторы, но не инвалидируются ссылки и указатели! Сами элементы дека остаются в тех же местах памяти, но во внутреннем векторе страниц, про который должен знать итератор дека, вообще говоря, может произойти реаллокация.
4. В `std::list` и `std::forward_list` ни итераторы, ни ссылки не инвалидируются. Так что если в приведённом примере заменить `vector` на `list`, то он будет корректно работать.

***
## Последовательные контейнеры

Последовательный контейнер хранит элементы последовательно, элементы располагаются друг рядом с другом. Стрелки показывают направления, в которых контейнер может эффективно расти:
![[Последовательные контейнеры.png]]

> [!INFO]
> За исключением forward_list все последовательные контейнеры  поддерживают произвольный доступ к любому элементу в контейнере. forvard_list же поддерживает только однонаправленный последовательный доступ.

Типы последовательных контейнеров:

- [[array]] - коллекция фиксированного размера. Добавлять или удалять элементы из контейнера нельзя.
- [[vector]] - коллекция переменного размера. 
- [[deque]] - двусторонняя очередь.
- [[list]] - двухсвязный список
- [[forvard_list]] - односвязный список.

***
## Адаптеры над контейнерами

Кроме последовательных контейнеров есть так называемые адаптеры контейнеров (container adaptor). Технически они не являются контейнерами, а инкапсулируют один из вышеописанных контейнеров (например, вектор) и позвляют работать с этими контейнерами определенным образом. Это следующие типы

- stack - представляет структуру данных "стек"
- queue - представляет структуру данных "очередь"
- priority_queue - также представляет очередь, но при этому ее элементы имеют приоритеты

***
## Ассоциативные контейнеры

Ассоциативные контейнеры (associative containers) представляют такие контейнеры, где с каждым элементом ассоциирован некоторый ключ, и этот ключ применяется для доступа к элементу в контейнере.

В С++ ассоциативные контейнеры представлены множествами (set) и картами/словарями (map).

***
## Неупорядоченные ассоциативные контейнеры



***