#Кастование

<!-- Когда мы используем приведение типов, компилятор запоминает от какого объекта на самом деле был получен указатель -->
#todo привести все про кастование в одно место
## RTTI

Для полиморфных типов (у которого есть хоть одна виртуальная функция) поддерживается RunTime Type Information. 

Оператор typeid определяет динамический тип.

```C++
#include <iostream>

struct Base {
    virtual void f() {
        std::cout << "Base\n";
    }
};

struct Derived: public Base {
    void f() override {
        std::cout << "Derived\n";
    }
};

int main() {
    Derived d;
    Base& b = d; // у b статический тип Base, но динамический тип - Derived
    
    b.f(); // "Derived"
    std::cout << typeid(b).name() << std::endl; // "7Derived"
}
```

## dynamic_cast

#dynamic_cast только для ссылок и указателей, а также только для полиморфных типов.

В случае неудачи dynamic_cast при кастовании к указателям вызвращает nullptr, а при кастовании к ссылкам будет RE std::bad_cast, которую можно отловить.

#todo сделать примеры для этих случаев
1) dynamic_cast может ксатовать "вбок", например от Mom к Dad, если тип на самом деле Son. static_cast даст CE, а reinterpret_cast - UB.
2) dynamic_cast может правильно кастовать "вниз" при виртуальном наследовании при том, что виртуальный предок полиморфный. static_cast выдаст CE, а reinterpter_cast - UB.
3) Для dynamuc_cast нужно, чтобы исходный тип был полиморфным (virtual).

```C++
#include <iostream>

struct Granny {
    int g;
    virtual void foo() {}
};

struct Mom: public Granny {
    int m;
};

struct Dad: public Granny {
    int f;
};

struct Son: public Mom, public Dad{
    int s;
};

int main(){
    Son s;

    Mom* pm = &s;
    Mom& rm = s;

//  Dad* pd = static_cast<Dad*>(pm);  // CE
    Dad* pd = dynamic_cast<Dad*>(pm); // OK, dynamic_cast использует RTTI, чтобы понять
                                      // можно ли выполнять каст 
    Dad& rd = dynamic_cast<Dad&>(rm); // OK
}
```
