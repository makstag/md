#lambda 

> [!INFO]
> Замыкание - возвращаемый тип `lambda`-функции генерируемый компилятором

Тип замыкания выводится компилятором, но мы можем использовать `trailing return type` для того, чтобы явно задать возвращаемый тип.

Если `lambda`-функция не принимает аргументов, можно не писать `()` :
```C++
auto helloworld = [] {
	std::cout << "Hello world!\n";
};

helloworld();
```
`Immediate invocation` - можно вызывать `lambda`-функции сразу же после объявления, например для того, чтобы принциниировать `const` переменную или переменную в списке инициализации класса:
```C++
// инициализация const переменной
const int x = [](int y) {
	if (y % 2 == 0)
		return y / 2;
	else
		return 3 * y + 1;
}(2024);

// инициализация поля класса в списке инициализации
class Foo {
public:
	const int n_;
	Foo();
};

Foo::Foo()
  : n_( []() -> int { return 42; }() )
{
}
```

***

Пример использования лямбд для сортировки вектора и сета:
```C++
#include <iostream>
#include <algorithm>
#include <vector>
#include <set>

int main() {
	auto cmp = [](int x, int y) { return x*x < y*y; };
	
	std::vector v = {5, -1, 4, -2, -3};

	std::sort(v.begin(), v.end(), cmp);
	for (auto x: v)
		std::cout << x << ' ';
	std::cout << '\n';

	// -----

	std::set<int, decltype(cmp)> s; // c++20
//	std::set<int, decltype(cmp)> s(cmp); // до c++20

	s.insert(-1);
	s.insert(-3);
	s.insert(2);
	for (int x : s)
		std::cout << x << ' ';
}
```

***
### Захват в lambda

Переменные, которые объявлены локально нельзя использовать в `lambda`-функциях и их нужно захватывать явно. Глобальные переменные можно использовать в `lambda`-функциях без явного захвата, например `std::cout`.
```C++
#include <iostream>
#include <algorithm>
#include <vector>

int main() {
	int c = 3;
	std::vector v = {1, 2, -3, 4, -5, 6};
	
	auto cmp = [c](int x, int y) {
		return (x-c)*(x-c) < (y-c)*(y-c);
	};

	std::sort(v.begin(), v.end(), cmp);
	for (auto x: v)
		std::cout << x << ' ';
}
```

Лекция 53  20:00