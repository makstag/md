#todo сделать наглядные графики с vtable
1) [cpp-casting](https://chuzcjoe.github.io/2023/12/06/cpp-casting/)
2) [habr vtable и отладка gdb](https://habr.com/ru/companies/otus/articles/479802/)
3) [C++ Vtable Example](https://itanium-cxx-abi.github.io/cxx-abi/cxx-vtable-ex.html)

```C++
#include <iostream>

struct A{};   // sizeof(A) - 1

struct B{     // sizeof(B) - 8, есть указатель на Vtable
	virtual void f(){}
	int b;
};

struct Derived : public Base{ // sizeof(Derived) - 16
	void f() override {}
	int d;
};

int main(){}
```

B_vtable
```C++
[ [typeinfo_ptr] [&B::f] ] 
```

5.8 Виртуальные функции с виртуальным наследованием

#todo перенести с листка

5.9 Some problems related to dynamuc dispatching

Первая проблема в том, что аргуметы по умолчанию подставляются в compile-time.

```C++
#include <iostream>

struct Base {
	virtual void f(int x = 1) const {
		std::cout << "Base " << x << '\n';
	}
};

struct Derived: public Base {
	void  f(int x = 2) const override {
		std::cout << "Derived " << x << '\n';
	}
};

int main() {
	const Base& b = Derived(); // "Derived 1"
	b.f(); 
}
```

Вторая проблема в том, что пока мы в конструкторе Base, v_pointer стоит на таблицу, как если бы это был Base. После того как Base создан и мы начинаем создавать Derived, значение v_pointer'a поменяется. Та же ситуация будет и для деструктора.

```C++
#include <iostream>

struct Base {
	Base() {
		f(0);
	}
	virtual void f(int x = 1) const {
		std::cout << "Base " << x << '\n';
	}
};

struct Derived: public Base {
	Derived() {
		f(1);
	}
	void f(int x = 2) const override {
		std::cout << "Derived " << x << '\n';
	}
};

int main() {
	const Base& b = Derived();  // "Base 0"
								// "Derived 1"
	b.f(2); // Derived 2
}
```

Третья проблема в том, что виртуальные функции у классов должны иметь определение, иначе компилятор не сможет создать vtable.  #todo подозрительный код

```C++
#include <iostream>

struct Base1 {
	void f();
};

struct Base2 {
	virtual void f();  // объявлена, но не определена '{}'
};

int main() {
	Base1 b1; // OK
//	Base2 b2; // undefined reference to `vtable for Base2'
			  // компилятор не смог создать vtable для Base
}
```

 C++ 13. Vtables, шаблоны.  49:30
https://www.youtube.com/watch?v=uCdJeq57TeM&list=PL4_hYwCyhAvazfCDGyS0wx_hvBmnAAf4h&index=13&t=1216s