## Лекция 44
#todo перенести

[class template argument deduction cppreference](https://en.cppreference.com/w/cpp/language/class_template_argument_deduction)

Можно для своего типа написать кастомные правила, как вывести тип аргумента шаблонного класса при переданных параметрах, это незывается `Explicit template deduction guides`

```C++
#include <vector>

template <typename T>
class Debug {
	Debug() = delete;
};

// маленькая реализация вектора
template <typename T>
struct vector {
    template <typename Iter>
    vector(Iter, Iter) {}
};

// С++17 пример Explicit template deducction guides
// Начиная с С++20 можно это не писать, он сам выведет.
// Тут мы говорим, что если в конструктор подаются два
// одинаковых параметра и они не подходят ни под что
// другое -> считать эти параметра итераторами
template <typename Iter>
vector(Iter, Iter)
-> vector<typename std::iterator_traits<Iter>::value_type>;

int main() {
	std::vector v = {1, 2, 3, 4, 5};
	vector v2(v.begin(), v.end());
	Debug<decltype(v)>
}
```

Пример агрегатной инициализации:
```C++
template <typename T, typename  U>
struct S{
	T x;
	U y;
};

// Выведет начиная с C++20
S s{1, 2.0};

// -----

struct A {};
struct B {};

template <typename T, typename  U>
struct S: T, U {};

// В С++17 нужен был бы deduction guide
template <typename T, typename  U>
S(T, U) -> S<T, U>;

// Выведет начиная с C++20 и без deduction guides
S s{A(), B()};

// -----

// можно даже наследоваться от переменного количества родителей
template <typename... Args>
struct S: Args... {};

// deduction guide
template <typename... Args>
S(Args...) -> S<Args...>;
```

### std::tuple
#typle

[std::tuple cppreference](https://en.cppreference.com/w/cpp/utility/tuple)

> [!INFO]
> `std::get()` возвращает тип в зависимости от переданного `tuple`, например:
> Если мы передали константный `tuple` - `std::get` вернет константную ссылку.
> Если мы передали `const rvalue tuple` - `std::get` вернет константную rvalue ссылку.

```C++
#include <iostream>
#include <tuple>

int main() {
	// можоно явно указывать шаблонные параметы
	std::tuple<int, double, char> t1{1, 2.0, 'a'};
	// можно положиться на их автоматический вывод
	std::tuple t2{1, 2.0, 'a'};
	
	// выбираем первый элемент, 1 - compile-type константа
	auto& d = std::get<1>(t);
	// structuted binding C++17, получаем копии
	auto [x1, y1, z1] = t;
	// structuted binding C++17, получаем ссылки
	auto& [x2, y2, z2] = t;
	// structuted binding C++17, в зависимости от того справа
	// у нас rvalue или lvalue tuple - получим либо rvalue
	// ссылки либо lvalue ссылки
	auto&& [x3, y3, z3] = t; // lvalue
	auto&& [x4, y4, z4] = std::move(t); // rvalue
}
```

> [!INFO]
> Есть три вида типов к которым применим `structured binding`
[structured binding cppreference](https://en.cppreference.com/w/cpp/language/structured_binding) 
> 1) array
> 2) tuple-like type
> 3) структура, которая допускает агрегатную инициализацию

***
## Лекция 45
[std::make_tuple cppreference](https://en.cppreference.com/w/cpp/utility/tuple/make_tuple)
[std::tie cppreference](https://en.cppreference.com/w/cpp/utility/tuple/tie)
[std::forward_as_tuple cppreference](https://en.cppreference.com/w/cpp/utility/tuple/forward_as_tuple)

Три способа создать `tuple` из набора значений: `std::make_tuple`, `std::tie` и `std::forward_as_tuple`

`std::make_tuple` создает `tuple` с отбрасыванием ссылок. С приходом [[3 CTAD - class template argument deduction]] практически заменил собой `std::make_tuple`.

`std::tie` создает `tuple` без отбрасывания ссылок. 

`std::forward_as_tuple` создает `tuple` из ссылок с сохранением видов ссылок.

Наивные реализации:
```C++
template <typename... Types>
auto make_tuple(Types&&... args)
		-> tuple<std::decay_t<Types>...> {
	return {std::forward<Types>(args)...};
}

template <typename... Args>
constexpr // since C++14
std::tuple<Args&...> tie(Args&... args) noexcept
{
    return {args...};
}

template <typename... Types>
auto forward_as_tuple(Types&&... args) -> tuple<Types&&...> {
	return {std::forward<Types>(args)...};
}
```

В пространстве имен std существует так же переменная `ignore_t ignore` которая позволяет игнорировать какие-то переменные, которые мы не хотим присваивать:
```C++
struct S
{
    int n;
    std::string s;
    float d;
 
    friend bool operator<(const S& lhs, const S& rhs) noexcept
    {
        // compares lhs.n to rhs.n,
        // then lhs.s to rhs.s,
        // then lhs.d to rhs.d
        // in that order, first non-equal result is returned
        // or false if all elements are equal
        return std::tie(lhs.n, lhs.s, lhs.d) < std::tie(rhs.n, rhs.s, rhs.d);
    }
};

// -----

struct ignore_t {
	template <typename T>
	void operator=(const U&) {}
};

ignore_t ignore

// -----

std::set<S> set_of_s;
S value{42, "Test", 3.14};

std::tie(iter, std::ignore) = set_of_s.insert(value);
```

27:30

----
## Лекция 46
// 1
```C++
template <typename T>
class unique_ptr{
    T* ptr;

public:
    unique_ptr(T* ptr): ptr(ptr) {}
    ~unique_ptr() {
        delete ptr;
    }
    unique_ptr(const unique_ptr&) = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;

    unique_ptr(unique_ptr&& other)
            : ptr(other.ptr) {
        othrt.ptr = nullptr;
    }
    unique_ptr& operator=(unique_ptr&& other) {
        if (this != &other) {
            delete ptr;
            ptr = other.ptr;
            other.ptr = nullptr;
        }
        return *this;
    }
}
```

// 2
```C++
T& opetaror() const {
    return *ptr;
}
T* operator->() const {
    return ptr;
}
```