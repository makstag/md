1. Методы
    <!-- - [Классы и структуры](#классы-и-структуры)
    - [Перегрузка функций](#перегрузка-функций)
    - [Конструкторы и деструкторы](#конструкторы-и-деструкторы)
    - [Делегирующие конструкторы](#делегирующие-конструкторы)
    - [Оператор присваивания и правило трех](#оператор-присваивания-и-правило-трех)
    - [default и delete](#default-и-delete)
    - [Перегрузка операторов](#перегрузка-операторов) -->

# Методы
## Константные методы

Иногда нужно использовать различную логику в зависимости от того константный объект вызвал метод или нет. Это этого используется квалификатор const. Он пишется справа от сигнатуры метода и означает, что данный метод принимает this по константной ссылке.

>Если есть только **константный** метод, **неконстантные** объекты также **смогут** его вызывать. Неявный каст от неконст. к конст. делается автоматически для методов с квалификатором const.

>Если есть только **неконстантный** метод, **неконстантные** объекты **не смогут** его вызывать.

```C++
char& operator[](size_t idx);
const char& operator[](size_t idx) const;
```

# Перегрузка операторов

1) Перегрузкой операторов нельзя поменять приоритет операторов
2) Нельзя добавлять собственные новые операторы
3) Нельзя перегружать операторы . :: ?

## Операторы сложения и инкремента

Выражаем оператор + через +=, а не наоборот из-за того, что += возвращает указатель, а не новый объект, что быстрее. Таким образом из этих четырех методов реализовать самостоятельно необходимо только один. Также оператор + важно реализовывать вне класса, чтобы избежать скрытого параметра this, который неявно добавляется к любой нестатической функции-члену. 

```C++
#include <iostream>
#include <vector>

using namespace std:

class BigInt {
    vector<int> digits;
public:
    BigInt& operator+=(const BigInt& another) {
        // ... logics
        return *this;
    }

    // Префиксный и постфиксный инкерменты
    BigInt& operator++() { // Префиксный
        return *this+=1;
    }
    BigInt& operator++(int) { // Посфиксный
        BigInt copy = *this;
        ++*this;
        return copy;
    }
};

BigInt operator+(BigInt a, const BigInt& b) {
    a += b;
    return a;
}
```

## Операторы сравнений

Операторы сравнений важно реализовывать вне класса, чтобы избежать скрытого параметра this, который неявно добавляется к любой нестатической функции-члену. Операторы == и < имеет смысл реализовать самостоятельно, а все остальные выразить через них. 

```C++
bool operator<(const BigInt& a, const BigInt& b) {
    // ... logics
    return true; // or false
}

bool operator>(const BigInt& a, const BigInt& b) {
    return b < a;
}

bool operator>=(const BigInt& a, const BigInt& b) {
    return !(a<b);
}

bool operator==(const BigInt& a, const BigInt& b) {
    // ... logics, можно !(a<b || b<a) но долго
    return true; // or false
}
```

## Оператор вывода в поток  <<

Оператор << принимает два аргумента: ссылку на объект потока (левый операнд) и фактическое значение для вывода (правый операнд). Затем он возвращает новую ссылку на поток, которую можно передать при следующем вызове оператора << в цепочке. Для ввода случай похожий, но нужно будет добавить friend.

```C++
// Вывод в поток
std::ostream& operator<<(std::ostream& out, const BigIbt) {
    // ... logics
    return out;
}
```

## Оператор <=>

Для упращения работы программисту в C++20 добавили оператор spaceship

```C++
std::weak_ordering operator<=>(const S&, const S&) = default
```

