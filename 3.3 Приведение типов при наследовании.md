1. [Приведедие типов при наследовании](#приведедие-типов-при-наследовании)
    - [Каст от потомка к родителю](#каст-от-потомка-к-родителю)
    - [Каст от родителя к потомку](#каст-от-родителя-к-потомку)
    - [Empty base optimization](#empty-base-optimization)

# Приведедие типов при наследовании

## Каст от потомка к родителю

Снаружи класса каст (даже static_cast, он проверяет доступ) разрешен только если наследование public.

```C++
#include <iostream>

struct Base {
    int a = 0;
    Base(){
        std::cout << "default" << std::endl;
    }
    Base(const Base&){
        std::cout << "copy" << std::endl;
    }
};

struct Derived: public Base {
    int a = 1;
    Derived() = default;
};

void f(Base b){
    std::cout << b.a << std::endl;  // 0
}

void f_ptr(Base* b){
    std::cout << b->a << std::endl; // 0
}

void f_ref(Base& b){
    std::cout << b.a << std::endl;  // 0
}

int main() {
    Derived d; // Выведется "default"
    std::cout << d.a << std::endl;  // 1

    f(d);      // Создается полноценная копия, вызывается конструктор
               // выведется "copy"
    f_ptr(&d); // OK, неявный каст в Base
    f_ref(d);  // OK, неявный каст в Base
}
```

## Каст от родителя к потомку

> Неявный каст от родителя к потомку - CE, нет конструктора. Можно через через static_cast к указателю, но это очень плохой кодстайл.

## Empty base optimization

Если у какого-то класса нет полей (только методы) - он занимает 1 байт, но если от него унаследовать что-то, то sizeof потомка не будет включать этот 1 байт. Также не будет никакого выравнивания. Если кастатнуть потомка к родителю указатель будет на первый байт потомка, sizeof родителя в таком случае так же будет 1.