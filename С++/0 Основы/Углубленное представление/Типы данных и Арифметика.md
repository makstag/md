#int #uint #float #double #integerpromoution #complited

https://habr.com/ru/companies/ruvds/articles/551216/

1. [Базовые целочисленные типы](#1-базовые-целочисленные-типы)
2. [Советы и предостережения integer point types](#2-советы-и-предостережения-integer-point-types)
    - [Общие советы](#общие-советы)
    - [Расширяющие преобразования](#расширяющие-преобразования)
    - [Сужающие преобразования](#сужающие-преобразования)
    - [Переполнение целых чисел](#переполнение-целых-чисел)
    - [Битовые сдвиги << >>](#битовые-сдвиги--)
3. [Советы и предостережения float point types](#3-советы-и-предостережения-float-point-types)
4. [Этапы выбора итогового типа в выражении](#4-этапы-выбора-итогового-типа-в-выражении)
5. [Ранги типов](#5-ранги-типов)

### 1 Базовые целочисленные типы

Целочисленные типы устанавливаются с помощью допустимой последовательности ключевых слов, взятых из набора `{char, short, int, long, signed, unsigned}`.  

Несмотря на то, что битовая ширина каждого базового целочисленного типа определяется реализацией (т.е. зависит от компилятора и платформы), стандартом закреплены следующие их свойства:  
- `char`: минимум 8 бит в ширину;
- `short`: минимум 16 бит и при этом не меньше `char`;
- `int`: минимум 16 бит и при этом не меньше `short`;
- `long`: минимум 32 бит и при этом не меньше `int`;
- `long long`: минимум 64 бит и при этом не меньше `long`.
В стандартной библиотеке [`<cstdint>`](https://en.cppreference.com/w/cpp/header/cstdint) определены типы со стандартной шириной в битах.
##### Дополнительные правила
- `sizeof(char)` всегда равен 1, независимо от битовой ширины `char`.
- Битовая ширина не обязательно должна отличаться. Например, допустимо использовать `char`, `short` и `int`, каждый шириной в 32 бита.
- Битовая ширина должна быть кратна 2. Например, `int` может иметь ширину 36 бит.
- Есть разные способы написания целочисленного типа. К примеру, в каждой следующей строке перечислен набор синонимов:  
    - `int`, `signed`, `signed int`, `int signed`;
    - `short`, `short int`, `short signed`, `short signed int`;
    - `unsigned long long`, `long unsigned int long`, `int long long unsigned`
    
***
### 2 Советы и предостережения integer point types

> [!IMPORTANT]  
> Знаковость типа `char` не специфицирована. В зависимости от платформы он может быть как знаковым, так и беззнаковым. Крайне рекомендуется пользоваться соответствующими типами uint8_t или int8_t. Или другими подходящими, если на вашей целевой платформе в char внезапно не 8 бит.

> [!WARNING]
> Типы меньше `int` (`char`, `bool`) неявно преобразуется в `signed int` (integer promotions)
##### Общие советы:
1. Не смешивайте в одном выражении знаковые и беззнаковые типы
2. Уделяйте особое внимание коду, работающему с типами, меньшими int в связи с правилом __integer promotions__.
4. Включайте предупреждения от компилятора обо всех неявных преобразованиях. Очень желательно трактовать их как ошибки. (-Wconversion, не всегда работает)
5. Не привносите неявные преобразования для своих типов — всегда помечайте однопараметрические конструкторы как `explicit`.
6. Если перегружаете операторы приведения (`operator T()`) для своих типов — также делайте их `explicit`.
7. Если ваши функции/методы рассчитаны на работу только с определенным примитивным типом, навешивайте на них ограничения с помощью шаблонов, SFINAE, концептов, или, что [очень просто](https://godbolt.org/z/Yx1e3d "https://godbolt.org/z/Yx1e3d"), механизма явного удаления перегрузок (`= delete`)

***
##### Расширяющие преобразования:
1. Числовые расширения __integer -> bigger integer__, __unsigned integer -> bigger unsigned integer__ всегда безопасны
2. Числовые расширения из __signed/unsigned integer types__ в __floating point types__ могут привести к потере точности для больших по абсолютной величине целыы чисел

```C++
int64_t i64{777'777'777'777'777'777}; // 777777777777777777
double d = i64;                       // 777777777777777792
float f = i64;                        // 777777757936418816

std::cout << i64 << std::endl;
std::cout << static_cast<int64_t>(d) << std::endl;
std::cout << static_cast<int64_t>(f) << std::endl;
```

> [!WARNING]
> При преобразовании __signed integer__ меньшей длины к __unsigned integer__ большей длины происходит знаковое расширение: старшие биты заполняются битом знака.

***
##### Сужающие преобразования:
1. Сужающие преобразования из знаковых или беззнаковых целых чисел в знаковые или беззнаковые целые числа меньшего размера могут привести к потере данных. Произойдет обрезание по модулю 2^N

```C++
int i1{ 30000 }; // 0x0111'0101'0011'0000 (30000)
int8_t c1 = i1;  // 0x0000'0000'0011'0000    (48)
int i2{ 30128 }; // 0x0111'0101'1011'0000 (30128)
int8_t c2 = i2;  // 0x0000'0000'1011'0000   (-80)

std::cout << static_cast<int>(c1) << std::endl;
std::cout << static_cast<int>(c2) << std::endl;
```

> [!TIP]
> Стоит заметить, что сужающее преобразование из целочисленного типа в другой целочисленный тип к неопределенному поведению не приводит, и выполнять побитовое `и` с маской перед присваиванием переменной меньшего типа не обязательно. Но желательно, чтобы избежать предупреждений компилятора 

1. Сужающие преобразования из вещественных в знаковые или беззнаковые целые числа:
	- если значение непредставимо в целочисленном типе -> это приведет к неопределенному поведению. Никаких обрезок по модулю 2^N не предполагается
	- если значение представимо -> произойдет "отбрасывание" всей дробной части

```C++
// непредставимо
constexpt uint16_t x = 1234567.0; // CE, undefined behavior

// представимо
int64_t i1 = 3.5; // 3
int64_t i2 = -3.5; // -3
std::cout << i1 << " " << i2 << std::endl;
```

***
##### Переполнение целых чисел:

>[!TIP]
>При выполнении инструкции `add` (`iadd`) платформы х86 переполнение целого числа сопровождается выставлением специального флага переполнения, а результирующее значение просто получается отбрасыванием старшего бита результата. И следует ожидать, что в таком случае произойдет перенос разряда в знаковый бит, и переменная примет отрицательное значение. В реализации конкретного языка программирования может быть проверка флага переполнения и сообщение об ошибке. А может и не быть. Может быть гарантия «цикличности» значений (после `2^31-1` идет `-2^31`), а может и не быть.  Может быть гарантия «цикличности» значений (после `2^31-1` идет `-2^31`), а может и не быть. 
###### Для знаковых чисел:
В языке C++ решили не жертвовать производительностью и не заставлять компиляторы генерировать код проверки переполнения, а объявили переполнение целых знаковых (`signed`) чисел неопределенным, открывая простор для оптимизаций. Компилятор может генерировать любой код, какой ему вздумается, ориентируясь лишь на одно правило: переполнения не бывает. Если вы работаете со знаковыми числами, либо используйте безопасные обертки, сообщающие каким-либо образом об ошибках. Либо выводите ограничения на входные данные программы целиком таким образом, чтобы переполнения не возникало, и не забывайте эти ограничения проверять.

> [!TIP]
> Можно отлавливать часть ошибок переполнения __signed integer types__ используя флаг компилятора `-fsanitize=undefined`

```C++
int32_t i = INT32_MAX;
int32_t i_in{};
int32_t i_known = 10;

std::cin >> i_in;

// компилятор не выдает предупреждений даже с флагами, но
// может произойти переполнение знакового числа
int32_t i_out1 = i*i_in;

// компилятор выдаст предупреждение (-fsanitize=undefined)
// /app/example.cpp:20:13: runtime error: signed integer overflow:
// 2147483647 * 10 cannot be represented in type 'int'
int32_t i_out2 = i*i_known;
```
###### Для беззнаковых чисел:
Если вы работаете только лишь с беззнаковыми числами (`unsigned`), то с неопределенным поведением при переполнении никаких проблем нет — все определено как вычисления по модулю `2^N` (N — количество бит для выбранного типа чисел).

***
##### Битовые сдвиги << >>:

> [!WARNING]
>стоит следовать общей рекомендации: любые битовые операции выполнять только в `unsigned` типах.

Для знаковых чисел результат операции битового сдвига определяется конкретной реализацией. В большинстве реализаций правый битовый сдвиг для знаковых чисел работает с помощью так называемого "арифметического сдвига". 

```C++
int number = -12;          // 0x1111'1111'1111'1111'1111'1111'1111'0100 (-12)
// При сдвиге все заполняется битом знака (1)
int result = number >> 31; // 0x1111'1111'1111'1111'1111'1111'1111'1111 (-1)
```

Когда вы делаете правый сдвиг для беззнаковых чисел, то просто старшие разряды заполняете нулями. Арифметический же сдвиг заполняет старшие разряды не нулями, а знаковым битом. Таким образом, правый сдвиг любого 4-х байтного знакового числа оставит после себя либо 32 бита нулей (в случае положительного числа), либо 32 бита единичек(в случае отрицательного числа). А все единички в битах - это -1 для знаковых чисел.

С++20 начинает нам гарантировать, что правый сдвиг для знаковых чисел выполняется с помощью арифметического сдвига.

***
### 3 Советы и предостережения float point types

> [!WARNING]
>Стандарт C++ не требует следования стандарту IEEE 754, потому деление на ноль в вещественных числах также считается неопределенным поведением, несмотря на то, что по IEEE 754 выражение x/0.0 определяется как -INF, NaN, или INF в зависимости от знака числа x (NaN для нуля).

> [!TIP]
> Поддерживается или нет IEEE 754 можно проверить с помощью предопределенной константы `std::numeric_limits<FloatType>::is_iec559`

1. Выражение x == y фактически является кривым побитовым сравнением для чисел с плавающей точкой, по особенному работающее со случаями -0.0 и +0.0, и NaN. О существовании этого и != операторов для вещественных чисел стоит забыть и никогда не вспоминать
2. Для побитового сравнения нужно использовать memcmp. Для сравнения чисел — приближенные варианты вида std::abs(x - y) < EPS, где EPS — какое-то абсолютное или вычисляемое на основе x и y значение. А также различные манипуляции с ULP сравниваемых чисел
3. Так как стандарт C++ не форсирует IEEE 754, проверки на `x == NaN` через его свойство `(x != x) == true` могут быть убраны компилятором, как заведомо ложные. Проверять нужно с помощью предназначенных для этого функций `std::isnan`
4. Сужающие преобразования из вещестенных в знаковые или беззнаковые целые числа могут повлечь неопределенное поведение, если значение непредставимо в целочисленном типе. Никаких обрезок по модулю 2^N не предполагается

```C++
constexpr uint16_t x = 1234567.0; // CE, undefined behavior
```

5. Вещественные числа до C++20 нельзя было использовать в качестве параметров-значений в шаблонах. Теперь же можно. Правда, ожидать, что вы насчитаете в run-time и в compile-time одно и то же — [не стоит](https://godbolt.org/z/q55891 "https://godbolt.org/z/q55891")
6. Для простой параметризации типов константами этот механизм вполне можно использовать без опасений. Однако строить на них паттерн-матчинг с выбором специализаций шаблонов крайне [не рекомендуется](https://godbolt.org/z/cGf9h94cn "https://godbolt.org/z/cGf9h94cn")

[IEEE-754 числа с плавающей точкой онлайн представление](https://www.h-schmidt.net/FloatConverter/IEEE754.html)
[Как сравнивать вещественные числа](https://bitbashing.io/comparing-floats.html)

***
### 4 Этапы выбора итогового типа в выражении

[cppreference - Usual arithmetic conversions](https://en.cppreference.com/w/cpp/language/usual_arithmetic_conversions)
##### 1 Применяется lvalue-to-rvalue conversion, получившиеся __prvalue__ используются далее вместо оригинальных операндов
##### 2 Если один из операндов floating-point type

1. Если оба операнда имеют один и тот же тип -> никакого преобразования не происходит
2. Иначе, если один из операторов не __floating-point type__ -> он конвертируется в тип второго операнда (floating-point)
3. Иначе, если ранги __floating-point type__ операндов упорядочены, но не равны -> операнд типа с меньшим рангом __floating-point type__ преобразуется в тип другого операнда
##### 3 Иначе, оба оператора integer types

1. Если какой-то из операндов T1, T2 меньше `int` по размеру (`char`, `bool`, ... ) -> он неявно преобразуется в `signed int` (integer promotions)
2. Если T1 и T2 имеют одинаковый тип -> это и будет результирующий тип
3. Иначе, если оба операнда __signed__ или оба __unsigned__ -> результирующий тип тот, который имеет больший ранг
4. Иначе, если один из типов __signed__, а другой __unsigned__ применяются следующие правила:
	- Если ранг __U__ операнда больше или равен рангу __S__ операнда -> результирующий тип будет тот, что имеет __U__ операнд
	- Иначе, если __S__ может представить все значения __U__ операнда -> результирующий тип будет тот, что имеет __S__ операнд
	- Иначе -> результирующий тип будет знаковый соответствующий __S__ типу.

***
### 5 Ранги типов
[draft - Conversion ranks](https://eel.is/c++draft/conv.rank)
##### Каждый floating point type имеет ранг преобразования с плавающей запятой, определенный следующим образом:  

1. Ранг стандартных типов с плавающей запятой уменьшается в следующем порядке:  
	- `long double`
	- `double`
	- `float`
2. Типы с плавающей запятой, имеющие одинаковые ранги преобразования с плавающей запятой, упорядочены по __floating-point conversion subrank__. Подранг формирует общий порядок среди типов с одинаковыми рангами
	- Типы `std::float16_t`, `std::float32_t`, `std::float64_t` и `std::float128_t` (типы с плавающей запятой фиксированной ширины) имеют больший подранг преобразования, чем любой стандартный тип с плавающей запятой с равным рангом преобразования. В противном случае порядок подрангов преобразования определяется реализацией.

##### Каждый целочисленный тип имеет ранг с соответствии со следующими правилами

1. Никакие два целочисленных типа со знаком, кроме __char__ и __signed char__, не имеют одинакового ранга, даже если они имеют одинаковое представление
2. Ранг __signed integer type__ больше, чем ранг любого __signed integer type__ меньшей ширины
3. Ранги __integer types__ в порядке уменьшения:
	- `long long`
	- `int`
	- `short`
	- `signed char`
4. Ранг любого __unsigned integer type__ равен рангу соответствующего __signed integer type__
5. Ранг любого стандартного целочисленного типа выше ранга любого __extended integer type__ той же ширины
6. Ранг bool меньше ранга всех стандартных целочисленных типов
7. Ранги __encoding character types__ (`char`, `char8_t`, `char16_t`, `char32_t` и `wchar_t`) равны рангам их базовых типов, что означает:
	- Ранг `char` равен рангу `signed char` и `unsigned char`
	- Ранг `char8_t` равен рангу `unsigned char`
	- Ранг `char16_t` равен рангу `std::uint_least16_t`
	- The rank of `char32_t` равен рангу `std::uint_least32_t`
	- Ранг `wchar_t` равен рангу его базового типа, определенного реализацией.


