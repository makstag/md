- [ ] Нужно еще написать про касты, которые от сына к отцу и обратно

#not_done

```C++
#include <iostream>

using namespace std;

struct Human {
    int h = 0;
    virtual void vfoo() { cout << "virtual human\n"; }
    void foo() { cout << "human "; }
};

struct Mom: public Human {
    int m = 1;
    void vfoo() override { cout << "virtual mom\n"; }
    void foo() { cout << "mom "; }
};

struct Dad: public Human {
    int d = 2;
    void vfoo() override { cout << "virtual dad\n"; }
    void foo() { cout << "dad "; }
};

struct Son: private Mom, public Dad{
    int s = 3;
    void vfoo() override { cout << "virtual son\n"; }
    void foo() { cout << "human "; }
};

int main(){
	Son son;
	Dad dad;
	Mom mom;
	Human human;

	// Неявные касты
    // Можно неявно приводить вверх, но приведение вниз
    // будет CE т.к нет конструктора
	{
		Dad d1 = son;    // ok, есть конструктор
		Dad* dp1 = &son; // ok
		Dad& dr1 = son;  // ok

//		Mom m1 = son;    // 'Mom' is an inaccessible base of 'Son'
//		Mom* mp1 = &son; // 'Mom' is an inaccessible base of 'Son'
//		Mom& mr1 = son;  // 'Mom' is an inaccessible base of 'Son'

//		Son s1 = dad;    // conversion from 'Dad' to non-scalar type
						 // 'Son' requested
//		Son* sp1 = &dad; // invalid conversion from 'Dad*' to 'Son*'
						 // [-fpermissive]
//		Son& sr1 = dad;  // invalid initialization of reference of type 'Son&'
                         // from expression of type 'Dad'

		// d1.foo();   d1.vfoo();    // dad , virtual dad
		// dp1->foo(); dp1->vfoo();  // dad , virtual son
		// dr1.foo();  dr1.vfoo();   // dad , virtual son
        // 2 2 2
        // cout << d1.d << " " << dp1->d << " " << dr1.d << "\n\n";
	}


	{
		Dad d1 = static_cast<Dad>(son);     // 
		Dad* dp1 = static_cast<Dad*>(&son); // 
		Dad& dr1 = static_cast<Dad&>(son);  // 

//		Mom m1 = static_cast<Mom>(son);     // 'Mom' is an inaccessible
											// base of 'Son'
//		Mom* mp1 = static_cast<Mom*>(&son); // 'Mom' is an inaccessible
											// base of 'Son'
//		Mom& mr1 = static_cast<Mom&>(son);  // 'Mom' is an inaccessible
											// base of 'Son'

//		Son s1 = static_cast<Son>(dad);     // no matching function for call to
											// 'Son::Son(Dad&)'
//		Son* sp1 = static_cast<Son*>(&dad); // UB
//		Son& sr1 = static_cast<Son&>(dad);  // UB

		d1.foo();   d1.vfoo();   // dad , virtual dad
		dp1->foo(); dp1->vfoo(); // dad , virtual son
		dr1.foo();  dr1.vfoo();  // dad , virtual son
	}

//     Mom* pm = &s;
//     Mom& rm = s;

// //  Dad* pd = static_cast<Dad*>(pm);  // CE
//     Dad* pd = dynamic_cast<Dad*>(pm); // OK, dynamic_cast использует RTTI, чтобы понять
//                                          // можно ли выполнять каст 
//     Dad& rd = dynamic_cast<Dad&>(rm); // OK
}
```

