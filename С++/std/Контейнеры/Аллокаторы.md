#allocators #аллокаторы

[Хабр Аллокаторы](https://habr.com/ru/articles/505632/)
[Оригинал статьи с бенчмарками](https://github.com/mtrebi/memory-allocators)

> [!INFO]
> Аллокаторы считаются равными, если одним можно удалить то, что выделено другим

> [!INFO]
> Последовательность обращений
> **Container -> allocator_traits ->Alloxator -> operator new -> malloc -> OS**

Наивная реализация аллокатора:
```C++
template <typename Alloc>
struct allocator_traits {
	template <typename U, typename... Args>
	// Аналогично устроен destroy
	static void construct(Alloc& alloc, U* ptr, const Args&... args) {
		if constexpr (/* Alloc has methos construct */) {
			alloc.construct(ptr, args...);
		} else {
			new (ptr) U(args...);
		}
	}
};

template <typename T>
struct allocator {
	T* allocate(size_t count) {
		// Дефолтная реализация new[] вызывает new, поэтому мы можем
		// сразу вызвать operator new (конструктор не будет вызываться)
		return operator new(count * sizeof(T));
		// return reinterpret_cast<T*>(new char[count  * sizeof(T)]);
	}
	void deallocate(T* ptr, size_t) {
		operator delete(ptr);
		// delete[] reinterpter_cast<char*>(ptr);
	}

	# Конструкторы должны уметь вызываться от типа, отличного от Т
	template <typename U, typename... Args>
	void construct(U* ptr, const Args&... args) {
		new (ptr) U(args...);
	}

	# Деструкторы также должны уметь вызываться от типа, отличного от Т
	template <typename U>
	void destroy(U* ptr) {
		ptr->~U();
	}

	# Аллокаторы должны уметь конструироваться от любых других аллокаторов
	template <typename U>
	allocator(allocator<U>) {}

	template <tupename U>
	struct rebind {
		using other = allocator<U>;
	};
};

template <typename T, typename Alloc = std::allocator<T>>
class list {
	struct BaseNode {
		BaseNode* prev;
		BaseNode* next;
	};
	struct Node : BaseNode {
		T value;
	};
	BaseNode fakeNode;
	size_t count;
	typename Alloc::template rebind<Node>::other alloc;

	list(const Alloc& alloc): fakeNode(), count(), alloc(alloc) {}
};

int main() {
	allocator<int> a;
	std::vector<int> v;
}
```

***
### allocator_traits
#allocator_traits
[cppreference allocator_traits](https://en.cppreference.com/w/cpp/memory/allocator_traits)

Стандартные контейнеры обязаны обращаться не к аллокатору напрямую, а к allocator_traits
```C++
template <typename Alloc>
struct allocator_traits {
	template <typename U, typename... Args>
	// Аналогично устроен destroy
	static void construct(Alloc& alloc, U* ptr, const Args&... args) {
		if constexpr (/* Alloc has methos construct */) {
			alloc.construct(ptr, args...);
		} else {
			new (ptr) U(args...);
		}
	}

};
```

***

Пример List с аллокатором:
```C++
template <typename T>
class list {
	struct BaseNode {
		BaseNode* next;
		BaseNode* prev;
	}
	struct Node : BaseNode {
		T value;
	};

	BaseNode fakeNode;
	size_t sz;
	typename Alloc::template rebind<Node>::other alloc;

public:
	list(): fakeNode {&fakeNode, &fakeNode}, sz(0) {}
	list(const Alloc& alloc): fakeNode(), sz(), alloc(alloc) {}
};
```

Можно, например, сделать аллокатор на стеке:
```C++
std::array<char, 1000000> arr;
StackAllocator<int> alloc(arr);
std::list<int, StackAllocator<int>> lst;
```

***
## Allocator-aware containers
[AllocatorAwareContainer cppreference](https://en.cppreference.com/w/cpp/named_req/AllocatorAwareContainer)

