## Переменные

#### Инициализация переменных

Если переменные или поля класса не проинициализированы явно, то там будут храниться случайные значения.

с (aggregate initialization). Она выполняется, когда массив инициализируется рядом значений в фигурных скобках:

```C++
int i[4] = {0, 1, 2, 3};
```

Если при этом не указать размер массива, то он выводится из количества значений, заключённых в скобки:

```C++
int i[0] = {0, 1, 2, 3, 4};

struct Widget {
  int i;
  float j;
};

Widget widget = {1, 3.14159};
```

Этот синтаксис работал ещё в С и С++98, причём, начиная с С++11, в нём можно пропускать знак равенства:

```C++
Widget widget{1, 3.14159};
```

Если определен собственный конструктор и мы пишем {}, то все равно вызывается он, а не происходит агрегатная инициализация! Также может быть специальный конструктор от initializer_list и тогда будет вызываться он при вызове {}.

В C++11 были добавлены инициализаторы элементов по умолчанию (default member initialisers).

```C++
struct Widget {
  int i = 0;
  float j = 0.f;
};
```

## Операторы

#### Приоритет операций

[Как читать сложные выражения](https://www.codeproject.com/Articles/7042/How-to-interpret-complex-C-C-declarations)

![[0_operators_priority.png]]
#### Оператор new

```C++
int *p = new int;
int *pp = new int(5);
int *set = new int[100]; // объявление массива
```

#### Оператор delete

```C++
delete p;
delete pp;
delete [] set; // освобождение памяти массива
```

#### Оператор typeid

Оператор typeid позволяет определить тип объекта во время выполнения. Применение:
```C++
typeid(bool).name() // b
```

Примеры вывода для разных типов:
```C++
bool = b
char = c
unsigned char = h
short = s
unsigned short = t
int = i
unsigned int = j
long = l
unsigned long = m
long long = x
unsigned long long = y
float = f
double = d
long double = e
string = Ss
int[] = A_i
double[] = A_d
vector<int> = St6vectorIiSaIiEE
set<int> = St3setIiSt4lessIiESaIiEE
pair<int, int> = St4pairIiiE
map<int, int> = St3mapIiiSt4lessIiESaISt4pairIKiiEEE
stack<int> = St5stackIiSt5dequeIiSaIiEEE
queue<int> = St5queueIiSt5dequeIiSaIiEEE
deque<int> = St5dequeIiSaIiEE
priority_queue<int> = St14priority_queueIiSt6vectorIiSaIiEESt4lessIiEE
tuple<int, int, int, int> = St5tupleIIiiiiEE
map< pair<int, int>, vector< priority_queue<int> > > = St3mapISt4pairIiiESt6vectorISt14priority_queueIiS2_IiSaIiEESt4lessIiEESaIS8_EES6_IS1_ESaIS0_IKS1_SA_EEE
```

## Квалификаторы и спецификаторы

#### const

Для переменных с ключевым словом const запрещены некторые операции: = += ++ -- и т.д. Также компилятор может решить оптимизировать выполнение программы и, например, не заводить ячейку памяти для переменной, а напрямую поставить ее в выражение.

Можно делать константные ссылки на неконстантные переменные:

```C++
int a = 0;
const int &b = a;
```

это одна и та же переменная, но обращаясь через b ее нельзя менять, а обращаясь через а - можно. Теперь (int &c = b) это CE.

#### static

Локальные статические переменные хранятся в static memory. Статическая переменная определяется только один раз и будет существовать, даже если объекты класса не были созданы. Если static массив проинициализирован, bin file будет содержать его в себе. Для инициализации статической переменной в классе нужно добавить ключевое слово inline.
```C++
statuc inline unsigned count{}; // инициализируем нулем
```
Статические функции – в отличие от глобальных функций, статические функции доступны только из файла объявления. Используйте статическую функцию, чтобы ограничить повторное использование того же имени функции в другом файле.

Статические функция-член класса — когда член функции объявляется статическим, он становится независимым от других объектов класса. Можно вызвать статическую функцию-член, даже если других объектов класса не существует. Чтобы получить доступ к именам класса, нужно использовать имя класса и оператор разрешения области « :: ». Статическая функция может обращаться только к другим статическим функциях, статическим членам данных и другим функицям вне класса.

