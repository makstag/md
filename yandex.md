
## 2.1. Первые шаги

`cin` читает поток данных до ближайшего пробельного разделителя (пробела, табуляции, перевода строки или просто конца файла). Чтобы считать в строковую переменную всю строчку целиком (не включая завершающий символ перевода строки), нужно использовать функцию [`std::getline`](https://en.cppreference.com/w/cpp/string/basic_string/getline) из заголовочного файла `string`:

```C++
#include <iostream>
#include <string>

int main() {
    std::string name;
    std::getline(std::cin, name);
    std::cout << "Hello, " << name << "!\n";
}
```

***
## 2.2. Типы данных

Беззнаковые типы можно спокойно переполнять: вычисления будут производиться по модулю соответствующей степени двойки. Другими словами, будут учтены только младшие биты результата. Наоборот, для знаковых типов переполнение приводит к так называемому [неопределённому поведению](https://en.cppreference.com/w/cpp/language/ub).

Такая ситуация не считается ошибкой компиляции, но в этом случае стандарт С++ перестаёт что-либо гарантировать по поводу поведения программы. Компиляторы могут использовать такие случаи для оптимизации программ, полагаясь на то, что разработчики пишут код корректно и никогда не допускают неопределённого поведения. Далее нам встретятся и другие случаи неопределённого поведения.

> [!INFO]
> При использовании `auto` со строками нужно быть осторожным. Важно знать, что конструкция `auto s = "hello"` выведет низкоуровневый тип `const char *` (указатель на неизменяемый набор символов в памяти), а не тип-обёртку `std::string`.

***
## 2.3 Ветвления и циклы

***
## 2.4 Векторы и структуры

```C++

std::vector<int> data = {1, 2, 3, 4, 5}; // список инициализации
std::vector<std::string> v1;  // пустой вектор строк
std::vector<std::string> v2(5);  // вектор из пяти пустых строк
std::vector<std::string> v3(5, "hello");  // вектор из пяти строк "hello"
```

```C++
# каноническая форма итерации по циклу
for (size_t i = 0; i != data.size(); ++i) {
    std::cout << data[i] << " ";
}
```

***