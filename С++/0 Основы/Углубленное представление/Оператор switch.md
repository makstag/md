#operator #switch 

[metanit switch](https://metanit.com/cpp/tutorial/2.17.php)
[Оригинальная статья](https://www.cyberforum.ru/blogs/18334/blog91.html)

С виду кажется, что switch в "нормальном" случае принципиально ничем не отличается от цепочки конструкций if - else if - ... По принципу действия действительно не отличается. Однако с точки зрения генерации кода switch принципиально строится по другому. Проще всего это опять пояснить на коротком примере.

```C++
switch (x)
{
  case 5:
    y = 10;
    break;
  case 6:
    y = 25;
    break;
  case 7:
    y = 38;
    break;
  ...
  case 20:
    y = 125;
    break;
  default:
    y = 1000;
    break; // можно опустить
}
```

В нижеидущем примере-аналоге используется конструкция "&&" - операция взятия адреса на метку. В языках Си и Си++ такой операции нет, однако с точки зрения генерируемого кода ничто не мешает тому, чтобы такая операция была, потому как в любом процессоре есть соответствующая аппаратная операция. Именно так рассуждали разработчики компилятора gcc и в своё расширение языка эту операцию внесли (ptr = &&L). А так же операцию перехода по указателю на метку (`goto *ptr`). Поэтому в примере-аналоге я буду использовать именно эту операцию. Таким образом наш switch аналогичен примеру:

```C++
/* Массив меток перехода на 16 альтернатив switch'а (от 5 до 20) */
static void *arr[16] = { &&L5, &&L6, &&L7, ..., &&L20 };
 
/* При таких значениях x мы попадаем в один из case'ов switch'а,
 * адрес для перехода загрузим из таблицы arr. При этом надо понимать, что
 * нулевой элемент таблицы соответствует значению x = 5. */
if (x >= 5 && x <= 20)
  goto *arr[x-5];
else
  goto L_default;
 
L5:
  y = 10;
L6:
  y = 25;
L7:
  y = 38;
  ...
L20:
  y = 125;
L_default:
  y = 1000;
```

Мы видим, что вместо длинной цепочки из 16-и if'ов мы имеем очень коротенький код по динамическому переходу (переходу на заранее неизвестный адрес). 

> [!TIP]
> Важно понимать, что скорость исполнения этого кода НЕ зависит от размеров таблицы: т.е. switch из 1000 элементов работает с такой же скоростью, как switch из 5 элементов (чего не скажешь о цепочке if'ов). В то время как массив с метками переходов является статически инициализированным (т.е. в бинарном файле лежит уже заполненная таблица, которую в run-time не надо перевычислять).  
  
Есть некоторые тонкие моменты, остающихся на усмотрение компилятора. Например, если в switch'е мы имеем всего две альтернативы 1 и 1000000, то таблица, построенная по такому принципу, занимала бы миллион слов (4 мегабайта в 32-битном режиме). Компилятор в таком случае вместо динамического перехода построит цепочку из двух if'ов.