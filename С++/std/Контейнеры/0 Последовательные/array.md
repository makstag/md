#array #not_complited
 [cppreference array](https://en.cppreference.com/w/cpp/container/array)
 [metanit array](https://metanit.com/cpp/tutorial/7.5.php)

Внутри `array<T, N>` является обёрткой над низкоуровневым массивом `T[N]`, но предоставляет интерфейс стандартного контейнера: знает свой размер, умеет присваиваться, предоставляет итераторы и т. д. Как и у вектора, элементы `array` располагаются в памяти непрерывно, но хранятся не в динамической памяти, а на стеке.

> [!INFO]
> Важно подчеркнуть, что размер `array` должен быть задан в момент компиляции и не может изменяться во время работы программы.

##### Объявление и инициализация array
Для создания объекта array в угловых скобках после названия типа необходимо передать его тип и размер:

```C++
#include <array>
 
int main()
{
	// 5 элементов контейнера имеют неопределенные значения.
    std::array<int, 5> numbers1;
    // неявная инициализация по умолчанию (нулями для int)
    std::array<int, 5> numbers2 {};
    // явная инициализация
    // (больше 5 элементов нельзя - CE, если меньше - остальные будут
    //  инициализированы по умолчанию нулями для int)
    std::array<int, 5> numbers3 {2, 3, 4, 5, 6};
    std::array<int, 5> numbers4 {2, 3, 4}; // {2, 3, 4, 0, 0}
    // c C++17 можно не указывать тип и количество элементов компилятор
    // сам выведет автоматически Однако в этом случае в списке инициализации
    // в фигурных скобках должно быть как минимум одно значение.
    std::array numbers5 {2, 3, 4, 5, 6};
}
```

##### Доступ к элементам
Для доступа к элементам контейнера array можно применять тот же синтаксис, что при работе с массивами - в квадратных скобках указывать индекс элемента, к которому идет обращение:

```C++
#include <array>
#include <iostream>
 
int main()
{   
    std::array<int, 5> numbers {2, 3, 4, 5, 6};
    // получаем значение элемента
    int n = numbers[2];
    std::cout << "n = " << n << std::endl; // n = 4
    // меняем значение элемента
    numbers[2] = 12;
    std::cout << "numbers[2] = " << numbers[2] << std::endl; // numbers[2] = 12
}
```

##### Перебор контейнера
С помощью стандартных циклов можно перебрать контейнер array:

```C++

#include <iostream>
#include <array>
#include <string>
  
int main()
{   
    const unsigned n = 5;
    std::array<std::string, n> people { "Tom", "Alice", "Kate", "Bob", "Sam" };
 
    // обращение через индексы
    for(int i{}; i < n; i++)
    {
        std::cout << people[i] << std::endl;
    }
    std::cout << std::endl;
    // перебор последовательности
    for (auto person : people)
    {
        std::cout << person << std::endl;
    }
}
```

### Основные функции array

В контейнер array нельзя добавлять новые элементы, так же как и удалять уже имеющиеся. Основные функции типа array, которые мы можем использовать:
- size(): возвращает размер контейнера
- at(index): возвращает элемент по индексу index
- front(): возвращает первый элемент
- back(): возвращает последний элемент
- fill(n): присваивает всем элементам контейнера значение n

Несмотря на то, что объекты array похожи на обычные массивы, тип array более гибок. Например, мы не можем присваивать одному массиву напрямую значения второго массива. В то же время объекту array мы можем передавать данные другого объекта array:

```C++
std::array<int, 5> numbers1 { 1, 2, 3, 4, 5 };
std::array<int, 5> numbers2 = numbers1;       // так можно сделать
 
int nums1[] = { 1,2,3,4,5 };
//int nums2[] = nums1;      // так нельзя следать
```

Также мы можем сравнивать два контейнера array:

```C++
std::array<int, 5> numbers1 { 1, 2, 3, 4, 5 };
std::array<int, 5> numbers2 { 1, 2, 3, 4, 5 }; 
  
std::cout << std::boolalpha << (numbers1 == numbers2) << std::endl;    // true
std::cout << std::boolalpha << (numbers1 != numbers2) << std::endl;    // false
std::cout << std::boolalpha << (numbers1 > numbers2) << std::endl;     // false
std::cout << std::boolalpha << (numbers1 < numbers2) << std::endl;     // false

```

Два контейнера сравниваются поэлементно. Так, в примере выше очевидно, что контейнеры numbers1 и numbers2 равны. Тогда как сравнение массивов начиная со стандарта C++20 объявлено устаревшим.