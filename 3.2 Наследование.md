<!-- 1. [Методы](#методы)
    - [Константные методы](#константные-методы)
    - [Статические методы](#статические-методы)
2. [Перегрузка операторов](#перегрузка-операторов)
    - [Операторы сложения и инкремента](#операторы-сложения-и-инкремента)
    - [Операторы сравнений](#операторы-сравнений)
    - [Операторы вывода в поток <<](#оператор-вывода-в-поток)
    - [Оператор <=>](#оператор)
    - [Функторы, перегрузка ()](#функторы-перегрузка)
    - [Перегрузка приведения типов](#перегрузка-приведения-типов)
    - [Добавление собственного литерального суффикста](#добавление-собственного-литерального-суффикса) -->

# Наследование
## Публичное, приватное и защищенное наследование

Это все compile-time проверки!

>Из наследника нельзя обращаться к приватной части родителя

>При public наследовании, все поля и методы, которые есть в базовом классе будут и с классе-наследнике. И мы - частный случай Base

>При private наследовании, обращаться к Base-методам и полям может только Derived и его дружественные классы.

>При protected наследовании, доступно методам и друзьям этого класса, а также его наследникам и их друзьям

Можно не писать ключевые слова public, private, protectetd при наследовании, в таком случае у классов по-умолчанию оно private, а у структур - public.

Однако иногда возникает необходимость в таких переменных и функциях базового класса, которые были бы доступны в производных классах, но не были бы доступны извне. То есть тот же private, только с возможностью доступа для производных классов. И именно для определения уровня доступа подобных членов класса используется спецификатор protected.


```C++
#include <iostream>

class Base{
public:
    int a = 0;
    void f() {
        std::cout << "Base\n";
    }
};

class Derived: protected Base {
public:
    int b = 1;
    void g() {
        std::cout << "Derived\n";
    }
};

class Subderived: public Derived {
public:
    void h() {
        std::cout << a;
    }
};

int main() {
    Derived d;
    d.g();
    d.f();
}
```


```C++
class Derived: protected Base {
public:
    int b = 1;
    void g(const Base& x) {
        std::cout << "Derived " << x.a << "\n";  // нельзя!
    }
    void g(const Derived& x) {
        std::cout << "Derived " << x.a << "\n";  // можно!
    }
};
```

## Видимость и доступность

Сначала проверяется видимость, а только потом доступность переменной или метода.

```C++
class Mom {
public:
    int a = 0;
    void f1() {
        std::cout << "Mom f1\n";
    }
    void f2() {
        std::cout << "Mom f2\n";
    }
};

class Son: Mom {
public:
    int a = 1;
    void f1() {  // Затмили метод
        std::cout << "Son f1\n";
    }
private:
    void f2() {  // Затмили метод
        std::cout << "Son f2\n";
    }
};

int main() {
    Son s;

    s.f(); // Son f1
    std::cout << s.a; // 1

    s.Mom::f(); // Mom f1
    std::cout<< s.Mom::a; // 0  

//  s.f2(); // CE - доступность проверяется после разрешения перегрузки и выбора версий и после выбора видимой переменной
    s.Mom::f(); // OK
}
```


Сначала компилятор выбирает тех кто притендует на вызов, а потом разрешает перегрузку.

```C++
class Mom {
public:
    int a = 0;
    void f(double) {  // Этот метод мы затмили в потомке
        std::cout << "Mom\n";
    }
};

class Son: Mom {
public:
    int a = 1;
    void f(int) {  // Затмили  метод
        std::cout << "Son\n";
    }
};

int main() {
    Son s;
    s.f(0.0); // Son - f(int) затмевает функию с таким же именем у родительского класса и будет неявное приведение к int

}
```

Скрин 2! using


using-конструкторы можно унаследовать конструкторы с C++11
это скрин 3