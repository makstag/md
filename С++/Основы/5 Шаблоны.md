 #templates #шаблоны

[Habr, неплохая статья про шаблоны в C++](https://habr.com/ru/companies/simbirsoft/articles/723062/)

Шаблоны можно создавать для функций, классов, структур, alias'ов и переменных.

Компилятор генерирует столько версий шаблонных функций/классов и т.д сколько разных вызовов было в программе. Если не было ни одного - компилятор просто проверист синтаксис функции/класса в общем случае.

Шаблонный префикс можно писать только в глобальной области видимости, namespace'е или классе. Нельзя, например, внутри функции объявить что-то шаблонное. Нет никакой разницы между **typename T** и **class T**, но лучше писать **typename T** для улучшения читаемости кода.

```C++
#include <iostream>

// Пример шаблонной функции
template <typename T>
T my_max(T a, T b) {
	return a > b & a : b;
}

// Пример шаблонного класса
template <typename T>
class C{
	T x;
};

// Пример шаблонного alias'а С++11
template <typename T>
using umap = std::unordered_map<T, T>;

umap<int> my_map; // == std::unordered_map<int, int> my_map

// Пример шаблонной переменной С++14
template <typename T>
T pi = 3.14;
```

Шаблон в шаблоне не все равно, что шаблон с двумя параметрами:
```C++
template <typename U>
struct S{
	T x;
	template <typename T> void f(T a, U b) // объявление
};

template <typename U>
template <typename T>
void S<U>::f(T a, U b) {} // опредление
```
#### Принципы выбора между несколькими при перегрузке 

Принципы выбора при нескольких вариантов такие:
1) Точное соответствие лучше, чем приведение типов
2) Частное лучше, чем общее
При этом, если есть только вариант с сигнаторой с одинаковыми типами f(T x, T y) и вызове с разными типами f(1.0, 0) - будет CE, так как компилятор не знает к какому типу ему нужно в итоге приводить параметры. Этого можно избежать явно указав шаблонные параметры. Также для функций можно указывать не все шаблонные параметры или же пустой шаблон <>. Пустой шаблон указывает компилятору, что нужно вызвать шаблонную версию функии.

```C++
#include <iosateam>

template <typename T, typename U>
void f(T x, U y) {
	std::cout << 1 << '\n';
}

template <typename T>
void f(T x, T y) {
	std::cout << 2 << '\n';
}

void f(int x, int y) {
	std::cout << 3 << '\n';
}

int main() {
	f(1, 1.0);   // 1
	f(1.0, 1.0); // 2
	f(1, 1);     // 3
}
```

Шаблонным параметрам можно давать значения по умолчанию. При этом параметры со значениями по умолчанию должны быть после параметров без значений по умолчанию:
```C++
template <typename T, typename U = int>
void f(T x) {
	U y;
	std::cout << y << '\n';
}

f(0); // OK, если бы шаблон был <typename T, typename U> - CE
```

#### Специализации шаблонов

Нельзя делать специализацию без общего типа, но можно запретить (delete) общий шаблон и разрешить только специализации(-ю). 

```C++
#include <iostream>

template <typename T>
struct S {
	T x = 0;
};

template <>
struct S<int> {
	int y = 0;
}

int main() {
	S<double> sd;
	S<int> si;

	sd.x; // OK
//	si.x; // CE 
}
```

#### Специализация шаблонных функций

Порядок выбора нужной версии:
1) сначала делается перегрузка между шаблонами
2) в выбраный шаблона подставляются аргумены и генерируются нужные весии
3) потом смотрим нет ли подходящей специализации для выбраной шаблонной версии

Для функций стандартом запрещена частичная специализация, только полная. 

```C++
template<typename T>
void f(){}

template<typename T>
void f<T*>(){} // ERROR, function template partial specialization 'f' is not allowed
```

Специализация относится к той версии, которая ближайщая сверху из подходящих. 

```C++
#include <iostream>

template <typename T, typename U>
void f(T, U) {
	std::cout << 1;
}

// Считается специализацией для void f(T, U)
template <>
void f(int, int) {
	std::cout << 3;
}

template <typename T>
void f(T, T) {
	std::cout << 2;
}

// Считается специализацией для void f(T, T)
// template <>
// void f(int, int) {
// 	std::cout << 4;
// }

int main() {
	// если раскомментировать специализацию
	// для void f(T, T) - выведется 4
	f(0, 0); // "2"
}
```

#### NTTP (Non-type template parameters)

В качестве параметра шаблона можно подставлять только константы. И только значения, известные на момент компиляции. До С++20 параметрома шаблонов могут быть только целочисленные значения.

```C++
#include <iostream>
#include <array>

template <typename Field, size_t M, size_t N>
class Matrix {};

template <typename Field, size_t N>
using SuareMatrix = Matrix<Field, N, N>;

template <typename Field, size_t M, size_t K, size_t N>
Matrix<Field, M, N> operator*(const Matrix<Field, M, K>& a,
							  const Matrix<Field, K, N>& b);

// Template template parameters
template <typename T, template<typename> class Contaiter>
class Stack {
	Container<T> container;
};

int main() {
	std::array<int, 100> a;

	Matrix<int, 5, 5> m;
	SquareMatrix<int, 5> sm;
}
```

#### Шаблонные вычисления

Пример вычисления чисел Фибаначчи на шаблонах

```C++
#include <iostream>

// g++ -ftemplate-depth=10000

template <int N>
struct Fibonacci {
	static constexpr int value = Fibonacci<N-1>::value + Fibonacci<N-2>::value;
};

template <>
struct Fibonacci<1> {
	static constexpr int value = 1;
};

template <>
struct Fibonacci<0> {
	static constexpr int value = 0;
};

int main() {
	std::cout << Fibonacci<20>::value;
}
```

#### Dependent names
#typename #template

>Tho phase translation - когда комилятор компилирует шаблонный код, ему приходится делать это в два прохода. Сначала до подставления шаблона T, потом после подставления шаблона T

По умолчанию поля шаблонных классов считаются компилятором за переменные. Для того, чтобы явно указать, что это тип переменной, а не сама переменная нужно дописать ключевое слово typename. (Случай 1)

В (Случай 2) недостаточно ключевого слово typename, нужно также явно указать, что B - шаблонный тип или компилятор будет парсить это как expression. Но, вроде G++11 справляется и без "template".

В (Случай 3) также придется явно указывать ключевое слово template, чтобы выражение не парсилось как expression.

В (Случай 4) если мы хотим обратиться к полю шаблонного родителя - нужно явно писать this (или явно разрешать поле видимости "Base::"), иначе компилятор не воспримет это как поле родителя.

```C++
#include <iostream>
#include <array>

template <typename T>
struct S {
	using A = int;

	template <int N>
	using B = std::array<int, N>;
};

template <>
struct S<double> {
	static const int A = 5;
};

template <typename T>
void f() {
	//  (1)
//	S<T>::A* x;          // считается expression по умолчанию
	typename S<T>::A* x; // now it's declaration

	//  (2)
	typename S<T>::template B < 10 > x;
}

int main() {
	f<int>();
}
```

```C++
#include <iostream>
#include <array>

template <typename T>
struct S {
	template <int N>
	void foo(int) {}
};

template <typename T>
void bar(int x, int y) {
	//  (3)
	S<T> s;
	s.template foo<5>(x+y);
}

int main() {
	f<int>();
}
```

```C++
#include <iostream>
#include <array>

template <typename T>
struct Base {
	int x = 0;
};

template <>
struct Base<double> {
};

template<typename T>
struct Derived : Base<T> {
	void f() {
//      ++x           // ERROR
		++this->x;    // OK
		++Base<T>::x; // OK
	}
};

int main() {
	f<int>();
}
```

#### Metafunctions and type traits

Для удобства работы с метафункциями в стандартной библиотеке есть #type_traits 
Начиная с C++14 в него добавили using'ги типа conditional_t, а начиная с С++17 добавили шаблонные переменные типа is_same_v.  Все это облегчает работу и позволяет писать меньше кода. Ниже приведены примеры реализации некоторых шаблонов из стандартной библиотеки. 
##### std::is_same

> if constexpr появился в C++17
> std::is_same появилась в C++11

```C++
#include <iostream>
#include <type_traits>

// Пример реализации std::is_same
template <typename T, typename U>
struct my_is_same {
	static constexpr bool value = false;
};

template <typename T>
struct my_is_same<T,T> {
	static constexpr bool value = true;
};

//c++17 добавили еще шаблонную переменную:
template <typename T, typename U>
const bool is_same_v = is_same<T, U>::value;
////

template <typename T, typename U>
void f(T x, U y) {
	// ...
	if constexpr (is_same<T, U>::value) {
		
	}
	// ...
}

int main() {
	f<int, std::string>(5, "abc");
}
```
##### std::remove_reference

```C++
#include <iostream>
#include <type_traits>

// Пример реализации std::remove_reference
template <typename T>
struct my_remove_reference {
	using type = T;
};

template <typename T>
struct my_remove_reference<T&> {
	using type = T;
};
////


template <typename T>
void f() {
	typename remove_reference<T>::type x;
}

int main() {}
```

##### std::conditional

```C++
// мета-тернарный оператор
// Пример реализации std::conditional
template <bool B, typename T, typename F>
struct conditional {
    using type = F;
};

template <bool B, typename T, typename F>
struct conditional<true, T, F> {
    using type = T;
};

// шаблонный using для conditional начиная с C++14
template <bool B, typename T, typename F>
using conditional_t = typename conditional<B, T, F>::type;
```

#### Variadic templates C++11

Начиная с C++11 можно создвать темплейты от произвольного количества шаблонных параметров. В примере, указанном ниже, функция print выводит первый шаблонный параметр и рекурсивно вызывает саму себя. Также нужна база print() без шаблонных параметров, которая ничего не выводит. 

> существует оператор std::sizeof...(tail), который возвращает в compile-time число, равное размеру пакета

```C++
#include <iostream>

void print() {}

template <typename Head, typename... Tail>
void print(const Head& head, const Tail&... tail) {
	std::cout << head << ' ';
	print(tail);
}

int main() {}
```

Пример проверки на однородность:
```C++
#include <iostream>

void print() {}

template <typename First, typename Second typename... Types>
struct is_homogeneous {
	static constexpr bool value = std::is_same_v<First, Second>
		&& is_homogeneous<Second, Types...>::value;
}

template <typename First, typename Second>
struct is_homogeneous<First, Second> {
	static constexpr bool value = std::is_same_v<First, Second>;
}


int main() {}
```