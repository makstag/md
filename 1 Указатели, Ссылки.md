1. [Указатели](#указатели)
    - [Арифметика указателей](#арифметика-указателей)
2. [Ссылки](#ссылки)

# Указатели

>Все стандартные функции выделения памяти возвращают указатель кратный максимально возможной степени двойки по которой могут ложиться типы (как правило 16).

>nullptr (типа std::nullptr_t) - аналог нуля для указателей. Раньше для этого использовался макрос NULL со значением 0 – целым типом. В целях обратной совместимости константа 0 также может использоваться в качестве нулевого указателя.

>**Void*** - указатель на произвольную память. Его нельзя разыменовать, но можно кастануть в какой-то тип указателя и присвоить в другой указатель, если по этой памяти действительно лежит переменная с таким типом, то все ок, иначе UB.

## Арифметика указателей

[pvs-studio](https://pvs-studio.ru/ru/blog/posts/cpp/0576/)
[Clarifying the C memory object model](https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2012.htm)

Арифметика указателей определена только для указателей, указывающих на объекты массива или элемент, следующий за последним. Сравнение указателей на равенство определено, если оба указателя происходят из одного и того же (многомерного) объекта массива. Таким образом, если два указателя указывают на разные объекты массива, тогда эти объекты массива должны входить в один и тот же многомерный массив для того, чтобы сравнить их. В противном случае это приводит к неопределенному поведению.

### операторы + -
В адресной арифметике для операторов "плюс" и "минус" указатель на объект, не являющийся элементом массива, ведёт себя, как указатель на начало массива длиной в один элемент, тип которого соответствует типу исходного объекта.

### оператор ==
Два указателя равны тогда и только тогда, когда оба являются нулевыми, либо указывают на один и тот же объект (в том числе указатель на объект и первый подобъект в составе объекта) или функцию, либо указывают на позицию за последним элементом массива, либо один указатель ссылается на позицию за последним элементом массива, а другой - на начало другого массива, следующего сразу за первым в том же адресном пространстве.

### операторы < <= > >=
Результат сравнения двух указателей зависит от взаимного расположения указываемых объектов в адресном пространстве. Если два указателя на объектные типы ссылаются на один и тот же объект, либо оба ссылаются на позицию за последним элементом одного и того же массива, то такие указатели равны. Если указываемые объекты являются членами одного и того же составного объекта, то указатели на члены структуры, объявленные позже, больше указателей на члены, объявленные раньше, а указатели на элементы массива с большими индексами больше указателей на элементы того же массива с меньшими индексами. Все указатели на члены одного и того же объединения равны. Если выражение P указывает на элемент массива, а выражение Q - на последний элемент того же массива, то значение указателя-выражения Q+1 больше, чем значение выражения P. Во всех остальных случаях поведение не определено.

# Ссылки

В ссылке, как и в указателе, хранится адрес объекта, расположенного в другой области памяти. В отличие от указателя, после инициализации ссылку нельзя перенаправить на другой объект или присвоить ей нулевое значение. Основные особенности:
1) При объявлении ссылка должны быть проинициализированна lvalue
2) Можно делать ссылки на функции (void (&F)() = g())
3) Нельзя делать ссылку на void
4) Нельзя делать массив ссылок (int& a[10]), но можно ссылку на массив (int (&a)[10])
5) Нельзя делать указатель на ссылку, но можно ссылку на указатель

```C++
int* p = nullptr;
int*& r = p;
```

6) Нельзя делать константный указатель int & const - CE

7) dangling reference — висячие ссылка возникают тогда, когда объект удалён, на который указывает ссылка удален. Пример, в случаях ниже ссылка будет указывать на локальную переменную функции, но при выходе из функции она снимается со стека и дальнейшее использование ссылки на нее будет UB.

```C++
int& f() {
  int x = 0;
  return x;
}

int& f(int x) {
  return x;
}
```

8) sizeof() ссылки будет возвращать размер объекта, а не размер указателя

```C++
struct S{
    int i[20];
};

int main()
{
   S s;
   S *ptr = &s;
   S &ref = s;
   
   cout << "sizeof S : " << sizeof(S) << endl;   // sizeof S : 80
   cout << "sizeof * : " << sizeof(ptr) << endl; // sizeof * : 8
   cout << "sizeof & : " << sizeof(ref) << endl; // sizeof & : 80
   return 0;
}
```

9) Обращение к объекту по ссылке будет занимать больше времени, чем напрямую к объекту т.к. будет выполняться разименование.

10) По указателям можно освобождать память, но это нежелательно. Хранение памяти по указателю скрывает от пользователя необходимость обращаться с памятью и затрудняет правильное выполнение этой операции. (https://stackoverflow.com/questions/3233987/deleting-a-reference)

```C++
int& f() {
  int *p = new int;
  return *p;
}

int &p = f();
delete &p;
```

11) нельзя перегружать функции следующим образом

```C++
void f(int);
void f(int&);
```

12) При создании ссылки на константную и несовпадении типов объектов может произойти неявный каст, который возвращает rvalue.
