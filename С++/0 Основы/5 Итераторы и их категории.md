#iterators #итераторы

**Output iterator** - итератор вывода поддерживает операции разыменования, допустимые только с левой стороны присваивания, и инкремента. Специальным случаем итератора вывода является ostream_iterator.

**Input Iterator** - поддерживает операции равенства, разыменования и инкремента.

**Forward Iterator** - все то же самое, что **Input Iterator**, но еще гарантирует, что если мы будем ходить по последовательности несколько раз не меняя ее, мы будем видеть одно и то же. Используется в следующих контейнерах - forward_list, unirdered_set, unordered_map.

**Bidirectionel Iterator** - все то же самое, что **Forward Iterator**, но еще поддерживает декремент. Используется в следующих контейнерах - list, set, map.

**Random Access Iterator** - все то же самое, что **Bidirectionel Iterator**, но еще может делать += число, -= число, разность двух указателей, сравнивать итератры (< > <= >=). Используется в deque.

**Contiguous Iterator C++17** - частный случай **Random Access Iterator**. Используется в следующих контейнерах - vector, array, также любой указатель T* это **Contiguous Iterator**. Гарантирует что:
```C++
*(&*it + n) == *(it + n)
```

***
#### Как узнать тип, который лежит под итератором
```C++
#include <iostream>
#include <iterator>
#include <vector>

template <typename InputIterator>
void find_most_often_number(InputIterator begin, InputIterator end) {
	typename std::iterator_traits<InputIterator>::value_type x = *begin;
}

// трюк позволяет увидеть от какого типа мы вызвались
// template <typename T>
// void f(T) = delete;

int main() {
	std::vector<bool> vb(10);
	f(*vb.begin());
}
```

***
##### range-based for основан на итераторах
```C++
std::set<int> s = {1, 2, 3, 4, 5};

// до С++11
for (std::set<int>::iterator it = s.begin(); it != s.end(); ++it) {
	std::cout << *it;
}

// после С++11
// просто синтаксический сахар, компилятор раскрывает
// все это до того, что сверху
for (int x : s) {
	std::cout << x;
}
```

***
#### Реализация итераторов, const- и reverse-iterators

```C++
#include <iostream>

template <typename T>
class vector {
	T* arr_;
	size_t sz_;
	size_t cap_;

public:

	template <bool IsConst>
	class base_iterator {
	public:
		using pointer_type = std::conditional_t<IsConst, const T*, T*>;
		using reference_type = std::conditional_t<IsConst, const T&, T&>;
		using value_type = T;
	private:
		pointer_type ptr;
		base_iterator(T* ptr): ptr(ptr) {}
	public:
		base_iterator(const base_iterator&) = default;
		base_iterator& operator=(const base_iterator&) = default;

		sreference_type operator*() const { return *ptr; }
		pointer_type operator->() const {	return ptr; }
		base_iterator& operator++() {
			++ptr;
			return *this;
		}
		base_iterator operator++(int) {
			base_iterator copy = *this;
			++ptr;
			return copy;
		}
	};

public:
	using iterator = base_iterator<false>;
	using const_iterator = base_iterator<true>;
	using reverse_iterator = std::reverse_iterator<iterator>;
	using const_reverse_iterator = std::reverse_iterator<const_iterator>;

	iterator begin() {
		return {arr_};
	}

	iterator end() {
		return {arr_ + sz_};
	}

	const_iterator begin() const {
		return {arr_};
	}

	const_iterator end() const {
		return {arr_ + sz_};
	}

	const_iterator cbegin() const {
		return {arr_};
	}

	const_iterator cend() const {
		return {arr_ + sz_};
	}

	/*
	void reserve(size_t newcap) {
		/**
	}

	void push_back(const T& value) {
		/**
	}
	*/
}

int main() {}
```

#### Реализация итераторов вывода

```C++
#include <iostream>
#include <algorithm>
#include <vector>

bool even(int x) {
	return x % 2 == 0;
}

// Наиваная реализация
template <typename Container>
class back_insert_iterator {
	Container& container;
public:
	back_insert_iterator(Container& container): container(container) {}
	// оператор разыменования *
	back_insert_iterator& operator=(const typename Container::value_type& value){
		container.push_back(value);
		return *this;
	}

	back_insert_iterator& operator++(){
		return *this;
	}

	back_insert_iterator operator++(int){
		return *this;
	}

	back_insert_iterator& operator*(){
		return *this;
	}
};

// Синтаксический сахар для back_insert_iterator
template <typename Container>
back_insert_iterator<Container> back_inserter(Container& container) {
	return {container};
}

int main() {
	int a[10] = {1, 2, 3, 4, 5};
	std::vector<int> v;
	
//	std::copy_if(a, a + 10, v.begin(), &even); // UB
	std::copy_if(a, a + 10,
	             std::back_insert_iterator<std::vector<int>>(v), &even); // OK
	std::copy_if(a, a + 10, std::back_inserter(v), &even); // also OK
}
```

***
#### Реализация std::distance

distance - считает расстояние между двумя итераторами. Наивная реализация:
```C++
#include <iostream>
#include <itarator>

template <typename Iterator>
typename std::iterator_traits<Iterator>::difference_type
distance(Iterator first, Iterator last) {
	if constexpr (std::is_base_of_v<
			std::random_access_iterator_tag,
	        typename std::iterator_traits<Iterator>::iterator_category
			>) {
		return last - first;
	}

	int i = 0;
	for (; first != last; ++i, ++first);
	return i;
}
```