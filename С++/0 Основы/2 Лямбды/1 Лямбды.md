#lambda 

> [!INFO]
> Замыкание - возвращаемый тип `lambda`-функции генерируемый компилятором

Тип замыкания выводится компилятором, но мы можем использовать `trailing return type` для того, чтобы явно задать возвращаемый тип.

Если `lambda`-функция не принимает аргументов, можно не писать `()` :
```C++
auto helloworld = [] {
	std::cout << "Hello world!\n";
};

helloworld();
```
`Immediate invocation` - можно вызывать `lambda`-функции сразу же после объявления, например для того, чтобы принциниировать `const` переменную или переменную в списке инициализации класса:
```C++
// инициализация const переменной
const int x = [](int y) {
	if (y % 2 == 0)
		return y / 2;
	else
		return 3 * y + 1;
}(2024);

// инициализация поля класса в списке инициализации
class Foo {
public:
	const int n_;
	Foo();
};

Foo::Foo()
  : n_( []() -> int { return 42; }() )
{
}
```

***

Пример использования лямбд для сортировки вектора и сета:
```C++
#include <iostream>
#include <algorithm>
#include <vector>
#include <set>

int main() {
	auto cmp = [](int x, int y) { return x*x < y*y; };
	
	std::vector v = {5, -1, 4, -2, -3};

	std::sort(v.begin(), v.end(), cmp);
	for (auto x: v)
		std::cout << x << ' ';
	std::cout << '\n';

	// -----

	std::set<int, decltype(cmp)> s; // c++20
//	std::set<int, decltype(cmp)> s(cmp); // до c++20

	s.insert(-1);
	s.insert(-3);
	s.insert(2);
	for (int x : s)
		std::cout << x << ' ';
}
```

***
### Захват в lambda

Переменные, которые объявлены локально нельзя использовать в `lambda`-функциях и их нужно захватывать явно. Глобальные переменные можно использовать в `lambda`-функциях без явного захвата, например `std::cout`.
```C++
#include <iostream>
#include <algorithm>
#include <vector>

int main() {
	int c = 3;
	std::vector v = {1, 2, -3, 4, -5, 6};
	
	auto cmp = [c](int x, int y) {
		return (x-c)*(x-c) < (y-c)*(y-c);
	};

	std::sort(v.begin(), v.end(), cmp);
	for (auto x: v)
		std::cout << x << ' ';
}
```
После захвата переменная хранится как поле внутри `lambda`-функции, например захват по значению и дальнейшее изменение переменной не повлияет на результат функции:
```C++
std::string hw = "Hello";
auto lam = [hw]() {	std::cout << hw; };
hw += " World!\n";

lam(); // print "Hello"
```



***

Нужно проверить:

Если мы захватываем по значению - мы не можем менять объект который захватили - будет CE.  Если мы захватили объкт по ссылке, его менять можно. Это происходит из-зв того, что `operator()` изначально константый. На объект переданный по ссылке `const`навешивается "справа" и на ссылку это не влияет. Можно сделать `operator()` неконстантным добавив в `lambda` ключевое слово `mutable`. 

***


[lambda captures cppreference](https://en.cppreference.com/w/cpp/language/lambda)
### Capture with initializaztion

```C++
std::string sub = "def";
auto lam = [sub = sub + 'g'](const std::string& str) {
	return std:find(sub) != std::string::npos;
};

// можно даже захватить по rvalue-ссылке
// и это единственный способ так сделать в lambda-функциях
auto lam = [sub = std::move(sub)](const std::string& str) {
	return std:find(sub) != std::string::npos;
};

// захват по константной ссылке, но ссылка все равно скопируется
// и будут разные адреса
auto lam = [sub = std::as_const(sub)](const std::string& str) {
	std::cout << &sub << '\n';
	return std:find(sub) != std::string::npos;
};

// можно захватить по константной ссылке
auto lam = [&sub = std::as_const(sub)](const std::string& str) {
	std::cout << &sub << '\n';
	return std:find(sub) != std::string::npos;
};
```

```C++
// можно захватить переменное число аргументов по ссылке
#include <iostream>
#include <vector>
#include <algorithm>
#include <utility>

std::vector<std::string> v = {"abcde", "cdefg", "fgeab"}; // global

template <typename... Str>
requires ((std::is_same_v<Str, std::string> && ...))
void test(const Str&... subs) {

	auto lam = [&subs...](const std::string& str) {
		return ((str.find(subs) != std::string::npos) && ...);
	};
	auto iter = std::find_if(v.begin(), v.end(), lam);

	std::cout << *iter << '\n';
}

int main() {
	std::stinrg sub = "cd";
	std::string sub2 = "de";
	test(sub, sub2);
}
```

```C++
#include <iostream>
#include <utility>

int main()
{
  int x = 1, y = 1;

  auto foo  = [&]() { return ++x + ++y; };
  
  // cannot assign to a variable captured by copy in a non-mutable lambda
  // auto foo2 = [=]() { return ++x + ++y; };
  
  auto foo3 = [=]() { return x + y; };
  auto foo4 = [x = std::move(x), y = std::move(y)] { return x + y; };

  // error: non-const lvalue reference to type 'typename
  // std::remove_reference<int &>::type' (aka 'int')
  // cannot bind to a temporary of type 'typename
  // std::remove_reference<int &>::type' (aka 'int')
  //auto foo5 = [&x = std::move(x), &y = std::move(y)] { return x + y; };

  auto foo6 = [x = std::as_const(x), y = std::as_const(y)] { return x + y; };
  auto foo7 = [&x = std::as_const(x), &y = std::as_const(y)] { return x + y; };
  auto foo8 = [=]() mutable { return x + y; };
}
```

```C++
#include <iostream>

struct S {
    int a = 3;
    auto getLambda() {
        // захватываем this, а не переменную 'a' как казалось бы
        // можно было бы явно захватить 'this' -> [this]
        // или явно захватить 'a' -> [a = a]
        // просто зават -> [a] является ошибкой компиляции
        auto f = [=](int x) {
            return x + a;
        };
        return f;
    }

};

int main() {
    S s1;
    S s2 = new S();

    auto f1 = s1.getLambda();

    // UB, s2 удалится к моменту вызова функции
    auto f2 = s2.getLambda();

    delete s2;
    std::cout << f1(5) << ' ' << f2(5);
}
```

Лекция 53  1:08:00

***

> [!WARNING]
> Статические переменные не нужно захватывать, они и так доступны внутри лямбды 

1) cpp insights проверить как функция без захвата отличается от функции с захватом

2) захват происходит только того, что используется

Лекция 54 11:00