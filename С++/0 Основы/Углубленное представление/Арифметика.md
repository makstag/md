#int #uint #float #double #integralpromoution #not_complited
### Советы и предостережения integer point types

> [!IMPORTANT]  
> Знаковость типа `char` не специфицирована. В зависимости от платформы он может быть как знаковым, так и беззнаковым. Крайне рекомендуется пользоваться соответствующими типами uint8_t или int8_t. Или другими подходящими, если на вашей целевой платформе в char внезапно не 8 бит.

> [!WARNING]
> Типы меньше `int` (`char`, `bool`) неявно преобразуется в `signed int` (integral promotions)
###### Общие советы:
1. Не смешивайте в одном выражении знаковые и беззнаковые типы
2. Уделяйте особое внимание коду, работающему с типами, меньшими int в связи с правилом __integral promotions__.
4. Включайте предупреждения от компилятора обо всех неявных преобразованиях. Очень желательно трактовать их как ошибки. (-Wconversion, не всегда работает)
5. Не привносите неявные преобразования для своих типов — всегда помечайте однопараметрические конструкторы как `explicit`.
6. Если перегружаете операторы приведения (`operator T()`) для своих типов — также делайте их `explicit`.
7. Если ваши функции/методы рассчитаны на работу только с определенным примитивным типом, навешивайте на них ограничения с помощью шаблонов, SFINAE, концептов, или, что [очень просто](https://godbolt.org/z/Yx1e3d "https://godbolt.org/z/Yx1e3d"), механизма явного удаления перегрузок (`= delete`):
###### Расширяющие преобразования:
1. Числовые расширения __integer -> bigger integer__, __unsigned integer -> bigger unsigned integer__ всегда безопасны
2. Числовые расширения из __signed/unsigned integer types__ в __floating point types__ могут привести к потере точности для больших по абсолютной величине целыы чисел

```C++
int64_t i64{777'777'777'777'777'777}; // 777777777777777777
double d = i64;                       // 777777777777777792
float f = i64;                        // 777777757936418816

std::cout << i64 << std::endl;
std::cout << static_cast<int64_t>(d) << std::endl;
std::cout << static_cast<int64_t>(f) << std::endl;
```

> [!WARNING]
> При преобразовании __signed integer__ меньшей длины к __unsigned integer__ большей длины происходит знаковое расширение: старшие биты заполняются битом знака.
###### Сужающие преобразования:
1. Сужающие преобразования из знаковых или беззнаковых целых чисел в знаковые или беззнаковые целые числа меньшего размера могут привести к потере данных. Произойдет обрезание по модулю 2^N

```C++
int i1{ 30000 }; // 0x0111'0101'0011'0000 (30000)
int8_t c1 = i1;  // 0x0000'0000'0011'0000    (48)
int i2{ 30128 }; // 0x0111'0101'1011'0000 (30128)
int8_t c2 = i2;  // 0x0000'0000'1011'0000   (-80)

std::cout << static_cast<int>(c1) << std::endl;
std::cout << static_cast<int>(c2) << std::endl;
```

2. Сужающие преобразования из вещественных в знаковые или беззнаковые целые числа:
	- если значение непредставимо в целочисленном типе -> это приведет к неопределенному поведению. Никаких обрезок по модулю 2^N не предполагается
	- если значение представимо -> произойдет "отбрасывание" всей дробной части

```C++
// непредставимо
constexpt uint16_t x = 1234567.0; // CE, undefined behavior

// представимо
int64_t i1 = 3.5; // 3
int64_t i2 = -3.5; // -3
std::cout << i1 << " " << i2 << std::endl;
```













###### Переполнение целых знаковых чисел:
1. 


```C++
int32_t i = INT32_MAX;   // 0x0111'1111'1111'1111'1111'1111'1111'1111
uint32_t u = UINT32_MAX; // 0x1111'1111'1111'1111'1111'1111'1111'1111

int32_t i2 = i*2;  // 0x1111'1111'1111'1111'1111'1111'1111'1110 (-2)
uint32_t u2 = u*2; // 0x1111'1111'1111'1111'1111'1111'1111'1110 (4294967294)

std::cout << i2 << std::endl;
std::cout << u2 << std::endl;
```














***
### Советы и предостережения float point types

> [!WARNING]
>Стандарт C++ не требует следования стандарту IEEE 754, потому деление на ноль в вещественных числах также считается неопределенным поведением, несмотря на то, что по IEEE 754 выражение x/0.0 определяется как -INF, NaN, или INF в зависимости от знака числа x (NaN для нуля).

> [!TIP]
> Поддерживается или нет IEEE 754 можно проверить с помощью предопределенной константы `std::numeric_limits<FloatType>::is_iec559`

1. Выражение x == y фактически является кривым побитовым сравнением для чисел с плавающей точкой, по особенному работающее со случаями -0.0 и +0.0, и NaN. О существовании этого и != операторов для вещественных чисел стоит забыть и никогда не вспоминать
2. Для побитового сравнения нужно использовать memcmp. Для сравнения чисел — приближенные варианты вида std::abs(x - y) < EPS, где EPS — какое-то абсолютное или вычисляемое на основе x и y значение. А также различные манипуляции с ULP сравниваемых чисел
3. Так как стандарт C++ не форсирует IEEE 754, проверки на `x == NaN` через его свойство `(x != x) == true` могут быть убраны компилятором, как заведомо ложные. Проверять нужно с помощью предназначенных для этого функций `std::isnan`
4. Сужающие преобразования из вещестенных в знаковые или беззнаковые целые числа могут повлечь неопределенное поведение, если значение непредставимо в целочисленном типе. Никаких обрезок по модулю 2^N не предполагается

```C++
constexpr uint16_t x = 1234567.0; // CE, undefined behavior
```

5. Вещественные числа до C++20 нельзя было использовать в качестве параметров-значений в шаблонах. Теперь же можно. Правда, ожидать, что вы насчитаете в run-time и в compile-time одно и то же — [не стоит](https://godbolt.org/z/q55891 "https://godbolt.org/z/q55891")
6. Для простой параметризации типов константами этот механизм вполне можно использовать без опасений. Однако строить на них паттерн-матчинг с выбором специализаций шаблонов крайне [не рекомендуется](https://godbolt.org/z/cGf9h94cn "https://godbolt.org/z/cGf9h94cn")

[IEEE-754 числа с плавающей точкой онлайн представление](https://www.h-schmidt.net/FloatConverter/IEEE754.html https://www.learncpp.com/cpp-tutorial/relational-operators-and-floating-point-comparisons/)
[Как сравнивать вещественные числа](https://bitbashing.io/comparing-floats.html)

***
## Общие правила

[cppreference - Usual arithmetic conversions](https://en.cppreference.com/w/cpp/language/usual_arithmetic_conversions)
##### 1 Применяется lvalue-to-rvalue conversion, получившиеся __prvalue__ используются далее вместо оригинальных операндов
##### 2 Если один из операндов floating-point type

1. Если оба операнда имеют один и тот же тип -> никакого преобразования не происходит
2. Иначе, если один из операторов не __floating-point type__ -> он конвертируется в тип второго операнда (floating-point)
3. Иначе, если ранги __floating-point type__ операндов упорядочены, но не равны -> операнд типа с меньшим рангом __floating-point type__ преобразуется в тип другого операнда
##### 3 Иначе, оба оператора integer types

1. Если какой-то из операндов T1, T2 меньше `int` по размеру (`char`, `bool`) -> он неявно преобразуется в `signed int` (integral promotions)
2. Если T1 и T2 имеют одинаковый тип -> это и будет результирующий тип
3. Иначе, если оба операнда __signed__ или оба __unsigned__ -> результирующий тип тот, который имеет больший ранг
4. Иначе, если один из типов __signed__, а другой __unsigned__ применяются следующие правила:
	- Если ранг __U__ операнда больше или равен рангу __S__ операнда -> результирующий тип будет тот, что имеет __U__ операнд
	- Иначе, если __S__ может представить все значения __U__ операнда -> результирующий тип будет тот, что имеет __S__ операнд
	- Иначе -> результирующий тип будет знаковый соответствующий __S__ типу.

***
## Ранги
[draft - Conversion ranks](https://eel.is/c++draft/conv.rank)

##### Каждый floating point type имеет ранг преобразования с плавающей запятой, определенный следующим образом:  

1. Ранг стандартных типов с плавающей запятой уменьшается в следующем порядке:  
	- `long double`
	- `double`
	- `float`
2. Типы с плавающей запятой, имеющие одинаковые ранги преобразования с плавающей запятой, упорядочены по __floating-point conversion subrank__. Подранг формирует общий порядок среди типов с одинаковыми рангами
	- Типы `std::float16_t`, `std::float32_t`, `std::float64_t` и `std::float128_t` (типы с плавающей запятой фиксированной ширины) имеют больший подранг преобразования, чем любой стандартный тип с плавающей запятой с равным рангом преобразования. В противном случае порядок подрангов преобразования определяется реализацией.

##### Каждый целочисленный тип имеет ранг с соответствии со следующими правилами

1. Никакие два целочисленных типа со знаком, кроме __char__ и __signed char__, не имеют одинакового ранга, даже если они имеют одинаковое представление
2. Ранг __signed integer type__ больше, чем ранг любого __signed integer type__ меньшей ширины
3. Ранги __integer types__ в порядке уменьшения:
	- `long long`
	- `int`
	- `short`
	- `signed char`
4. Ранг любого __unsigned integer type__ равен рангу соответствующего __signed integer type__
5. Ранг любого стандартного целочисленного типа выше ранга любого __extended integer type__ той же ширины
6. Ранг bool меньше ранга всех стандартных целочисленных типов
7. Ранги __encoding character types__ (`char`, `char8_t`, `char16_t`, `char32_t` и `wchar_t`) равны рангам их базовых типов, что означает:
	- Ранг `char` равен рангу `signed char` и `unsigned char`
	- Ранг `char8_t` равен рангу `unsigned char`
	- Ранг `char16_t` равен рангу `std::uint_least16_t`
	- The rank of `char32_t` равен рангу `std::uint_least32_t`
	- Ранг `wchar_t` равен рангу его базового типа, определенного реализацией.


