1. [Указатели](#указатели)
2. [Ссылки](#ссылки)

# Указатели

**Void*** - указатель на произвольную память. Его нельзя разыменовать, но можно кастануть в какой-то тип указателя и присвоить в другой указатель, если по этой памяти действительно лежит переменная с таким типом, то все ок, иначе UB.

Все стандартные функции выделения памяти возвращают указатель кратный максимально возможной степени двойки по которой могут ложиться типы (как правило 16).

nullptr (типа std::nullptr_t) - аналог нуля для указателей. Раньше для этого использовался макрос NULL со значением 0 – целым типом. В целях обратной совместимости константа 0 также может использоваться в качестве нулевого указателя.

# Ссылки

В ссылке, как и в указателе, хранится адрес объекта, расположенного в другой области памяти. В отличие от указателя, после инициализации ссылку нельзя перенаправить на другой объект или присвоить ей нулевое значение. Основные особенности:
1) При объявлении ссылка должны быть проинициализированна lvalue
2) Можно делать ссылки на функции (void (&F)() = g())
3) Нельзя делать ссылку на void
4) Нельзя делать массив ссылок (int& a[10]), но можно ссылку на массив (int (&a)[10])
5) Нельзя делать указатель на ссылку, но можно ссылку на указатель

```C++
int* p = nullptr;
int*& r = p;
```

6) Нельзя делать константный указатель int & const - CE

7) dangling reference — висячие ссылка возникают тогда, когда объект удалён, на который указывает ссылка удален. Пример, в случаях ниже ссылка будет указывать на локальную переменную функции, но при выходе из функции она снимается со стека и дальнейшее использование ссылки на нее будет UB.

```C++
int& f() {
  int x = 0;
  return x;
}

int& f(int x) {
  return x;
}
```

8) sizeof() ссылки будет возвращать размер объекта, а не размер указателя

```C++
struct S{
    int i[20];
};

int main()
{
   S s;
   S *ptr = &s;
   S &ref = s;
   
   cout << "sizeof S : " << sizeof(S) << endl;   // sizeof S : 80
   cout << "sizeof * : " << sizeof(ptr) << endl; // sizeof * : 8
   cout << "sizeof & : " << sizeof(ref) << endl; // sizeof & : 80
   return 0;
}
```

9) Обращение к объекту по ссылке будет занимать больше времени, чем напрямую к объекту т.к. будет выполняться разименование.

10) По указателям можно освобождать память, но это нежелательно. Хранение памяти по указателю скрывает от пользователя необходимость обращаться с памятью и затрудняет правильное выполнение этой операции. (https://stackoverflow.com/questions/3233987/deleting-a-reference)

```C++
int& f() {
  int *p = new int;
  return *p;
}

int &p = f();
delete &p;
```

11) нельзя перегружать функции следующим образом

```C++
void f(int);
void f(int&);
```

12) При создании ссылки на константную и несовпадении типов объектов может произойти неявный каст, который возвращает rvalue.
