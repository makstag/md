## Лекция 44
#todo перенести

[class template argument deduction cppreference](https://en.cppreference.com/w/cpp/language/class_template_argument_deduction)

Можно для своего типа написать кастомные правила, как вывести тип аргумента шаблонного класса при переданных параметрах, это незывается `Explicit template deduction guides`

```C++
#include <vector>

template <typename T>
class Debug {
	Debug() = delete;
};

// маленькая реализация вектора
template <typename T>
struct vector {
    template <typename Iter>
    vector(Iter, Iter) {}
};

// С++17 пример Explicit template deducction guides
// Начиная с С++20 можно это не писать, он сам выведет.
// Тут мы говорим, что если в конструктор подаются два
// одинаковых параметра и они не подходят ни под что
// другое -> считать эти параметра итераторами
template <typename Iter>
vector(Iter, Iter)
-> vector<typename std::iterator_traits<Iter>::value_type>;

int main() {
	std::vector v = {1, 2, 3, 4, 5};
	vector v2(v.begin(), v.end());
	Debug<decltype(v)>
}
```

Пример агрегатной инициализации:
```C++
template <typename T, typename  U>
struct S{
	T x;
	U y;
};

// Выведет начиная с C++20
S s{1, 2.0};

// -----

struct A {};
struct B {};

template <typename T, typename  U>
struct S: T, U {};

// В С++17 нужен был бы deduction guide
template <typename T, typename  U>
S(T, U) -> S<T, U>;

// Выведет начиная с C++20 и без deduction guides
S s{A(), B()};

// -----

// можно даже наследоваться от переменного количества родителей
template <typename... Args>
struct S: Args... {};

// deduction guide
template <typename... Args>
S(Args...) -> S<Args...>;
```

### std::tuple
#typle

[std::tuple cppreference](https://en.cppreference.com/w/cpp/utility/tuple)

> [!INFO]
> `std::get()` возвращает тип в зависимости от переданного `tuple`, например:
> Если мы передали константный `tuple` - `std::get` вернет константную ссылку.
> Если мы передали `const rvalue tuple` - `std::get` вернет константную rvalue ссылку.

```C++
#include <iostream>
#include <tuple>

int main() {
	// можоно явно указывать шаблонные параметы
	std::tuple<int, double, char> t1{1, 2.0, 'a'};
	// можно положиться на их автоматический вывод
	std::tuple t2{1, 2.0, 'a'};
	
	// выбираем первый элемент, 1 - compile-type константа
	auto& d = std::get<1>(t);
	// structuted binding C++17, получаем копии
	auto [x1, y1, z1] = t;
	// structuted binding C++17, получаем ссылки
	auto& [x2, y2, z2] = t;
	// structuted binding C++17, в зависимости от того справа
	// у нас rvalue или lvalue tuple - получим либо rvalue
	// ссылки либо lvalue ссылки
	auto&& [x3, y3, z3] = t; // lvalue
	auto&& [x4, y4, z4] = std::move(t); // rvalue
}
```

> [!INFO]
> Есть три вида типов к которым применим `structured binding`
[structured binding cppreference](https://en.cppreference.com/w/cpp/language/structured_binding) 
> 1) array
> 2) tuple-like type
> 3) структура, которая допускает агрегатную инициализацию





----
## Лекция 46
// 1
```C++
template <typename T>
class unique_ptr{
    T* ptr;

public:
    unique_ptr(T* ptr): ptr(ptr) {}
    ~unique_ptr() {
        delete ptr;
    }
    unique_ptr(const unique_ptr&) = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;

    unique_ptr(unique_ptr&& other)
            : ptr(other.ptr) {
        othrt.ptr = nullptr;
    }
    unique_ptr& operator=(unique_ptr&& other) {
        if (this != &other) {
            delete ptr;
            ptr = other.ptr;
            other.ptr = nullptr;
        }
        return *this;
    }
}
```

// 2
```C++
T& opetaror() const {
    return *ptr;
}
T* operator->() const {
    return ptr;
}
```