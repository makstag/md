по Правила гонки -  гонка происходит если сколько угодно потоков читают область памяти и хотя бы один одновременно пишет в нее же.

```C++
unsigned x = 0, i = 0, j = 0; // области памяти
void readerf() { while (i++ < 'g') x += 0x1; }
void writerf() { while (j++ < 'g') x += 0x10000; }
std::thread t1{readerf}, t2{writerf};
// Все равно не определено, что будет на экране, несмотря на то, что запись и
// чтение в разнах потоках 'трогают' разные байты
t1.join(); t2.join();
```

Если заменить unsigned x = 0 на char x[2] = {0, 0} - это уже не будет UB так как теперь x это не сказярный объект, а агрегат, который состоит из скалярных объектов.

>std::cout по стандарту - потокобезопасен

Интерфейс std::mutex:
- lock() - Попытка вызвать повторно в том же потоке это UB. Также может кинуть исключение std::system_error
- try_lock() - То же, что и для lock()
- unlock() - Попытка разблокировать не захваченый mutex это тоже UB

std::lock_guard<__T__> это RAII обертка над любым классом, поддерживающим интерфейс из методов lock() и unlock(). lock_guard нельзя копировать и перемещать. Использование lock_guard не дороже, чем использование mutex.



