#Кастование
# Приведедие типов при наследовании

## Каст от потомка к родителю

Снаружи класса каст (даже static_cast, он проверяет доступ) разрешен только если наследование public.

```C++
#include <iostream>

struct Base {
    int a = 0;
    Base(){
        std::cout << "default" << std::endl;
    }
    Base(const Base&){
        std::cout << "copy" << std::endl;
    }
};

struct Derived: public Base {
    int a = 1;
    Derived() = default;
};

void f(Base b){
    std::cout << b.a << std::endl;  // 0
}

void f_ptr(Base* b){
    std::cout << b->a << std::endl; // 0
}

void f_ref(Base& b){
    std::cout << b.a << std::endl;  // 0
}

int main() {
    Derived d; // Выведется "default"
    std::cout << d.a << std::endl;  // 1

    f(d);      // Создается полноценная копия, вызывается конструктор
               // выведется "copy"
    f_ptr(&d); // OK, неявный каст в Base
    f_ref(d);  // OK, неявный каст в Base
}
```

## Каст от родителя к потомку

> Неявный каст от родителя к потомку - CE, нет конструктора. Можно через через static_cast к указателю, но это очень плохой кодстайл.