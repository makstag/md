# Классы

#### Классы и структуры

* Отличаются только тем, что у классов поля по-умолчанию private, а у структуры public
* После определения структуры нужно ставить точку с запятой
* Данный структуры называются полями

```C++
struct S {
  int x = 1;
  double y = 3.14;
  char c = 'a';
};
```

* Можно инициализаровать поля при создании переменной S s{2, 2.72, 'b'}; (aggregate initialization) Те, переменные, которые не пронициализированы таким образом будут проинициализированы по-умолчанию. Если инициализации по-умолчанию нет, там будет мусор т.к. переменная лежит на стеке.
* Начиная с C++20 можно напрямую указывать какие поля инициализировать - designated initializers.
S s {.y = 2.72, .c = 'b' };
* Обращаться к полям структуры через оператор " . "
* Если нужно обратиться к полям указателя на структуру - используется оператор     " -> " 
* В структуре можно объявлять методы
* есть ключевое слово this - указатель на данный объект
* можно метод объявить внутри структуры, но определить вне
* внутри структур можно тоже объявлять структуры (inner classes)

Можно объявлять структуры внутри функций - local classes.

#### Инкапсуляция и модификаторы доступа

Смотреть подробнее:
[[3.2 Наследование#Публичное, приватное и защищенное наследование]]
  
Функциям не членам класса можно разрешать доступ к приватным полям (только ко всем сразу) используя ключевое слово friend. Отношение дружбы не симметрично и не транзитивно.

```C++
friend void g();
```

Разрешить доступ можно и классам, тогда всем методам класса будут доступны приватные поля.

```C++
friend class SS;
```

Ключевое слово friend не рекомендовано код-стайлом.

#### Перегрузка функций

1) Можно делать перегрузку в зависимости от того константное значение передается или нет:

```C++
void f(T&);
void f(const T&);
```

2) Нельзя перегружать передачу по значению и передачу по костантной ссылке - будет umbiguous call:

```C++
void f(T);
void f(const T&);  // ERROR
```

3) Нельзя перегружать передачу по значению и передачу по ссылке - будет umbiguous call:

```C++
void f(T);
void f(T&);  // ERROR
```

#### Конструкторы и деструкторы

Конструктор и деструктор всегда объявляются в разделе public.

Если мы определяем свой конструктор, то компилятор больше не создает конструктор по умолчанию. И при создании объекта нам надо обязательно вызвать определенный нами конструктор.

Если все поля проинициализированы по умолчанию, можно создать свой конструктор по умолчанию Widget::Widget(){} и теперь объявлять экземпляр класса как Widget w;

Когда мы зашли в тело конструктора - все поля уже проинициализированы.

Конструкторы и указатели на vtable:
![[privedenie_tipov_pri_nasledovanii.ogg]]

Списки инициализации - constructor initializer list C++98 (не путать с теми, которые появились в C++11 - brace-enclosed initializer list) позволяет инициализировать переменную значением до входа в тело конструктора. Это быстрее за счет того, что переменные сразу будут проинициализировыны нужными значениями, а не мусором с последующей перезаписью нужным значением в теле конструктора. Также это позволяет инициализировать переменные у которых нет инициализации по умолчанию, например константные переменные или ссылки. Иначе при попытке создать конструктор по умолчанию компилятор выдаст CE.

```C++
class Complex {
public:
  double re = 0.0;
  double im = 0.0;

  Complex(double re, double im): re(re), im(im)
}
```

Если перечислить переменные в другом порядке, то будет ворнинг. Поля всегда инициализируются в том порядке в котором объявлены, а не в том, каком они указаны в списке инициализации.

```C++
Complex(double re, double im): im(im), re(re)  // warning if -Wall -Wextra flags on
```

inializer_list

При подобных вызовах initialize_list приоритетнее обычного конструктора:

```C++
vector<int> v{1, 10};
```

> Начиная с C++11 все предпичитали inializer_list при инициализации, а начиная с C++17 можно не уточнять от чего vactor. И теперь рекомендуется не использовать {}, а использовать () если только не хочешь явно использовать inializer_list
#### Делегирующие конструкторы

Начиная с C++11 один конструктор может делегировать некоторые работы другому. Чтобы добавить делегированные конструкторы, используйте constructor (. . .) : constructor (. . .) синтаксис. Причем конструктор делегирования должен быть единственным членом списка инициализации.

```C++
class class_a {
public:
    class_a() {}
    // member initialization нет делегирования
    class_a(string str) : m_string{ str } {}

    // невозможно выполнить member initialization здесь
    // error C3511: конструктор делегирования должен быть единственным членом списка инициализации
    class_a(string str, double dbl) : class_a(str) , m_double{ dbl } {}

    // конструктор делегирует часть работы другому конструктору
    class_a(string str, double dbl) : class_a(str) { m_double = dbl; }
    double m_double{ 1.0 };
    string m_string;
};
```
#### Оператор присваивания и правило трех

```C++
String s = ss; // оператор копирования
s = ss;        // оператор присваивания
```

Операторы присваивания, копирования генерируются компилятором автоматически.
Правило трех - как только в классе хоть из трех вещей нужно реализовать самостоятельно (оператор копирования, присваивания, деструктор), то нужно реализовать все три.

#### default и delete
> c C++11

Компилятор может сам генерировать шесть функций.
• Конструктор по умолчанию;
Object();
• деструктор;
~Object();
• копирующий конструктор;
Object(const Object& oth);
• оператор копирующего присваивания;
Object& operator=(const Object& oth);
• перемещающий конструктор;
Object(Object&& oth);
• оператор перемещающего присваивания;
Object& operator=(Object&& oth);

Ключевое слово default указывает на то, что мы хотим использовать версию этой функции сгенерированную компилятором, указывать тело функции в таком случае не нужно. Ключевое слово delete наоборот запрещает компилятору автоматически генерировать функцию с такой сигнатурой.

```C++
class C {
  C(const C&) = default;
  C(C&&) = delete;
};
```

## static поля класса

```C++
#include <iostream>
#include <cstdio>

class NonStatic 
{
public:
    std::string name{"Ilya"}; // OK
    unsigned age{18};         // OK
    double d = 7.77;          // OK
    double* dp = &d;          // OK
    double* np{nullptr};      // OK

    void print() 
    {
        printf("Нестатические члены класса\n");
        printf("name: %s age: %d\n", name.c_str(), age);
        printf("d через разым. указатель: %f\n", *dp);
        std::cout << "Адрес dp: " << dp << std::endl;
        std::cout << "Адрес np: " << np << std::endl;
    }
};

class Static 
{
public:
    static uint i;                       // OK
//  static int i1 = 0;                   // Нельзя - нужно определять снаружи
//  static double d1 = 0;                // Нельзя - нужно определять снаружи
    const static uint ci = 5;            // OK - интегральный тип
//  const static float d1 = 0;           // Нельзя - доступно только для интегральных типов
    constexpr static double ex_d = 8.88; // OK
};

uint Static::i = 4;

int main()
{
    // Нестатические члены класса
    NonStatic nS;
    nS.print();
    
    //Статические члены класса
    printf("\nСтатические члены класса\n");
    printf("%d %d\n", Static::i, Static::ci);
    printf("%f\n", Static::ex_d);
}
```

#### mutable поля класса

Спецификатор mutable позволяет менять переменную даже в константном методе и используется, чтобы указать, что член не влияет на видимое извне состояние класса (часто используется для мьютексов, кэшей заметок, отложенных вычислений и инструментов доступа).

```C++
class ThreadsafeCounter
{
    mutable std::mutex m; // The "M&M rule": mutable and mutex go together
    int data = 0;
public:
    int get() const
    {
        std::lock_guard<std::mutex> lk(m);
        return data;
    }
 
    void inc()
    {
        std::lock_guard<std::mutex> lk(m);
        ++data;
    }
};
```
